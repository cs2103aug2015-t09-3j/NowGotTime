# A0126509E
###### ./command/Command.java
``` java

package command;

import helper.CommonHelper;
import object.State;

public interface Command {

    /**
     * Returns Command object from parsed text
     */
    public static Command parseCommand(String text) throws Exception {
        String commandType = CommonHelper.getFirstWord(text);
        String arguments = CommonHelper.removeFirstWord(text);
        
        Command command;
        
        switch (commandType.toLowerCase()) {
            case CommandAdd.KEYWORD:
                command = CommandAdd.parseCommandAdd(arguments);
                break;
            case CommandEdit.KEYWORD:
                command = CommandEdit.parseCommandEdit(arguments);
                break;
            case CommandDelete.KEYWORD:
                command = CommandDelete.parseCommandDelete(arguments);
                break;
            case CommandUndo.KEYWORD:
                command = new CommandUndo(arguments);
                break;
            case CommandRedo.KEYWORD:
                command = new CommandRedo(arguments);
                break;
            case CommandView.KEYWORD:
                command = CommandView.parseCommandView(arguments);
                break;
            case CommandSearch.KEYWORD:
                command = CommandSearch.parseCommandSearch(arguments);
                break;
            case CommandCheck.KEYWORD:
                command = new CommandCheck(arguments);
                break;
            case CommandUncheck.KEYWORD:
                command = new CommandUncheck(arguments);
                break;
            case CommandSet.KEYWORD:
                command = new CommandSet(arguments);
                break;
            case CommandExit.KEYWORD:
                command = new CommandExit(arguments);
                break;
            default:
                // throw exception if it is not a valid command
                throw new Exception(String.format(CommonHelper.ERROR_INVALID_COMMAND, commandType));
        }
        return command;
    }
    
    /**
     * Executes this command
     */
    public String execute(State state) throws Exception;
    
    /**
     * Returns a displayable object
     */
    public Displayable getDisplayable();
}
```
###### ./command/CommandAdd.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;

public interface CommandAdd extends Command, Revertible {
    
    public static final String KEYWORD = "add";
    
    public static CommandAdd parseCommandAdd(String text) throws Exception {
        
        CommandAdd commandAdd = null;
        if (Parser.matches(text, Parser.PATTERN_ADD_KEYWORD_TO_PROJECT) 
                || Parser.matches(text, Parser.PATTERN_ADD_INDEX_TO_PROJECT)) {
            commandAdd = new CommandAddToProject(text);
            
        } else if (Parser.matches(text, Parser.PATTERN_PROJECT)) {
            commandAdd = new CommandAddProject(text);
            
        } else if (Parser.matches(text, Parser.PATTERN_ADD_EVENT) 
                || Parser.matches(text, Parser.PATTERN_ADD_TASK) 
                || Parser.matches(text, Parser.PATTERN_NAME)) {
            commandAdd = new CommandAddItem(text);
            
        } else if (Parser.matches(text, Parser.PATTERN_ADD_PROGRESS)) {
            commandAdd = new CommandAddProgress(text);
            
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandAdd.KEYWORD));
            
        }
        
        
        return commandAdd;
    }
    
}
```
###### ./command/CommandAddItem.java
``` java

package command;

import java.util.Calendar;
import java.util.regex.Matcher;

import helper.CalendarHelper;
import helper.CommonHelper;
import helper.Parser;
import object.Event;
import object.Item;
import object.State;
import object.Todo;
import service.ServiceHandler;

public class CommandAddItem implements CommandAdd {
    
    private Item item;
    
    /**
     * Parses the arguments for add command
     */
    public CommandAddItem(String args) throws Exception {
        // try to parse command arguments in one of these
        if (Parser.matches(args, Parser.PATTERN_ADD_EVENT)) {
            item = parseAsEvent(args);
        } else if (Parser.matches(args, Parser.PATTERN_ADD_TASK)) {
            item = parseAsTodo(args);
        } else if (Parser.matches(args, Parser.PATTERN_NAME)) {
            item = parseAsFloatingTodo(args);
        } else {
            assert(false);
        }
        
        
    }
    
    /**
     * Constructs this command from specified Item object
     */
    public CommandAddItem(Item item) {
        this.item = item;
    }
    
    /**
     * Returns item object of this command
     */
    public Item getItem() {
        return this.item;
    }
    
    private static Event parseAsEvent(String args) {
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_ADD_EVENT);
        
        String name = matcher.group(Parser.TAG_NAME);
        String start = matcher.group(Parser.TAG_START);
        String end = matcher.group(Parser.TAG_END);
        
        
        Calendar startCalendar = Calendar.getInstance();
        CalendarHelper.updateCalendar(startCalendar, start);
        
        Calendar endCalendar =  (Calendar) startCalendar.clone();
        CalendarHelper.updateCalendar(endCalendar, end);
        
        String startDate = CalendarHelper.getDateString(startCalendar);
        String startTime = CalendarHelper.getTimeString(startCalendar);
        String endDate = CalendarHelper.getDateString(endCalendar);
        String endTime = CalendarHelper.getTimeString(endCalendar);
        
        return new Event(name, startDate, endDate, startTime, endTime, "");
    }
    
    private static Todo parseAsTodo(String args) {
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_ADD_TASK);
        
        String name = matcher.group(Parser.TAG_NAME);
        String due = matcher.group(Parser.TAG_DATETIME);
        
        Calendar dueCalendar = Calendar.getInstance();
        CalendarHelper.updateCalendar(dueCalendar, due);
        
        String dueDate = CalendarHelper.getDateString(dueCalendar);
        String dueTime = CalendarHelper.getTimeString(dueCalendar);
        
        return new Todo(name, "", dueDate, dueTime);
    }
    
    private static Todo parseAsFloatingTodo(String args) {
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
        
        String name = matcher.group(Parser.TAG_NAME);
        
        return new Todo(name);
    }


    /**
     * Executes add command, returns feedback string
     */
    @Override
    public String execute(State state) throws Exception {
        ServiceHandler serviceHandler = state.getServiceHandler();
        serviceHandler.createItem(item);
        return String.format(CommonHelper.SUCCESS_ITEM_CREATED, item.getName());
    }

    /**
     * Delete the added command
     */
    @Override
    public String revert(State state) throws Exception {
        Command revertAddCommand = new CommandDeleteItem(item);
        return revertAddCommand.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        String date;
        if (item instanceof Event) {
            date = ((Event)item).getStartDateString();
        }
        else {
            if (((Todo)item).hasDate()) {
                date = ((Todo)item).getDeadlineDateString();
            } else {
                return new CommandViewDate();
            }
        }
        
        return new CommandViewDate(date);
    }
}
```
###### ./command/CommandAddProgress.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.State;
import project.Projects;

public class CommandAddProgress implements CommandAdd {

    private int index;
    private String progress;
    private String projectName;
    
    public CommandAddProgress(String args) {
        
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_ADD_PROGRESS);
        
        progress = matcher.group(Parser.TAG_PROGRESS);
        index = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
    }
    
    public CommandAddProgress(int index, String projectName, String progress) {
        this.index = index;
        this.progress = progress;
        this.projectName = projectName;
    }

    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        Projects projectHandler = state.getProjectHandler();
        
        if (projectName == null) {
            if (currentDisplay instanceof CommandViewProjectName) {
                projectName = ((CommandViewProjectName) currentDisplay).getProjectName();
            } else {
                throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
            }
        }
        
        if (projectHandler.addProgressMessage(index, projectName, progress)) {
            return CommonHelper.SUCCESS_PROGRESS_ADDED;
        } else {
            if (projectHandler.listExistingProjects().contains(projectName)) {
                throw new Exception(CommonHelper.ERROR_PROJECT_NOT_FOUND);
            } else {
                throw new Exception(CommonHelper.ERROR_FAIL_ADD_PROGRESS);
            }
        }
    }

    @Override
    public String revert(State state)
            throws Exception {
        Command revertAddProgressCommand = new CommandDeleteProgress(index, projectName);
        return revertAddProgressCommand.execute(state);
    
    }


    @Override
    public Displayable getDisplayable() {
        return null;
    }

}
```
###### ./command/CommandAddProject.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.State;
import project.Projects;

public class CommandAddProject implements CommandAdd {

    private String projectName;
    
    public CommandAddProject(String args) {
        
        if (Parser.matches(args, Parser.PATTERN_PROJECT)) {
            Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_PROJECT);
            projectName = matcher.group(Parser.TAG_NAME);
        } else {
            projectName = args;
        }
        
    }

    @Override
    public String execute(State state) throws Exception {
        Projects projectHandler = state.getProjectHandler();
        
        if (projectHandler.createProject(projectName)) {
            return String.format(CommonHelper.SUCCESS_PROJECT_CREATED, projectName);
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_DUPLICATE_PROJECT, projectName));
        }
    }

    @Override
    public String revert(State state)
            throws Exception {
        CommandDeleteProject commandDeleteProject = new CommandDeleteProject("project \"" + projectName + "\"");
        return commandDeleteProject.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        return new CommandViewProject();
    }

}
```
###### ./command/CommandAddToProject.java
``` java

package command;

import java.util.ArrayList;
import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.Event;
import object.Item;
import object.State;
import project.Projects;
import service.ServiceHandler;

public class CommandAddToProject implements CommandAdd {

    private int index;
    private String keyword = null;
    private String projectName;
    private Item item;
    
    public CommandAddToProject(String args) {
        Matcher matcher;
        
        if (Parser.matches(args,Parser.PATTERN_ADD_INDEX_TO_PROJECT)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_ADD_INDEX_TO_PROJECT);
            index = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
            projectName = matcher.group(Parser.TAG_NAME);
            
        } else if (Parser.matches(args,Parser.PATTERN_ADD_KEYWORD_TO_PROJECT)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_ADD_KEYWORD_TO_PROJECT);
            keyword = matcher.group(Parser.TAG_KEYWORD);
            projectName = matcher.group(Parser.TAG_NAME);
            
        }
    }
    
    public CommandAddToProject(Item item, String projectName) {
        this.item = item;
        this.projectName = projectName;
    }

    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        ServiceHandler serviceHandler = state.getServiceHandler();
        Projects projectHandler = state.getProjectHandler();
        
        if (item == null) {
            if (keyword == null) {
                if (currentDisplay instanceof CommandViewDate
                        || currentDisplay instanceof CommandSearch) {
                    item = serviceHandler.viewItemByIndex(index);
                }
                if (item == null) {
                    throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
                }
            } else {
                ArrayList<Item> filteredItem = serviceHandler.search(keyword);
                
                if (filteredItem.size() == 0) {
                    throw new Exception(String.format(CommonHelper.ERROR_ITEM_NOT_FOUND, keyword));
                } else if (filteredItem.size() > 1) {
                    return String.format(CommonHelper.ERROR_MULTIPLE_OCCURRENCE, keyword);
                } else {
                    item = filteredItem.get(0);
                }
            }
        }
        
        // TODO: handle item already on the list
        if (!(item instanceof Event)) {
            throw new Exception(CommonHelper.ERROR_TODO_ON_PROJECT);
        } else if (projectHandler.addProjectEvent(((Event)item), projectName)) {
            return String.format(CommonHelper.SUCCESS_ADDED_TO_PROJECT, item.getName(), projectName);
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_PROJECT_NOT_FOUND, projectName));
        }
        
    }

    @Override
    public String revert(State state)
            throws Exception {
        Command revertAddToProjectCommand = new CommandDeleteFromProject(item, projectName);
        return revertAddToProjectCommand.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        if (item == null) {
            return new CommandSearch(keyword);
        } else if (keyword == null) {
            // refresh current display if edit by index
            return null;
        } else {
            return new CommandViewProjectName(projectName);
        }
    }

}
```
###### ./command/CommandCheck.java
``` java

package command;

import java.util.ArrayList;
import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.Item;
import object.State;
import project.Projects;
import service.ServiceHandler;

public class CommandCheck implements Command, Revertible {

    public static final String KEYWORD = "check";

    private String itemKey = null;
    private int itemIndex;
    private Item item;
    
    public CommandCheck(String args) throws Exception {
        Matcher matcher;
        
        if (Parser.matches(args,Parser.PATTERN_NAME)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
            itemKey = matcher.group(Parser.TAG_NAME);
        } else if (Parser.matches(args,Parser.PATTERN_INTEGER)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_INTEGER);
            itemIndex = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
        } else {
            // undo command accepts no arguments
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandCheck.KEYWORD));
        }
    }

    public CommandCheck(Item item) {
        this.item = item;
    }

    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        ServiceHandler serviceHandler = state.getServiceHandler();
        Projects projectHandler = state.getProjectHandler();
        
        
        if (item == null) {
            if (itemKey == null) {
                if (currentDisplay instanceof CommandViewProjectName) {
                    String projectName = ((CommandViewProjectName)currentDisplay).getProjectName();
                    item = projectHandler.editEvent(itemIndex, projectName);
                } else if (currentDisplay instanceof CommandViewDate
                        || currentDisplay instanceof CommandSearch) {
                    item = serviceHandler.viewItemByIndex(itemIndex);
                }
                
                if (item == null) {
                    throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
                }
            } else {
                ArrayList<Item> filteredItem = serviceHandler.search(itemKey);
                
                if (filteredItem.size() == 0) {
                    throw new Exception(String.format(CommonHelper.ERROR_ITEM_NOT_FOUND, itemKey));
                } else if (filteredItem.size() > 1) {
                    return String.format(CommonHelper.ERROR_MULTIPLE_OCCURRENCE, itemKey);
                } else {
                    item = filteredItem.get(0);
                }
            }
        }
        
        if (serviceHandler.mark(item)) {
            return String.format(CommonHelper.SUCCESS_ITEM_CHECKED, item.getName());
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_ALREADY_CHECKED, item.getName()));
        }
    }
    
    @Override
    public String revert(State state)
            throws Exception {
        CommandUncheck commandUncheck = new CommandUncheck(item);
        return commandUncheck.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        if (item == null) {
            return new CommandSearch(itemKey);
        } else if (itemKey == null) {
            // refresh current display if edit by index
            return null;
        } else {
            // display item's date
            return new CommandViewDate(item.getDisplayDateString());
        }
    }

}
```
###### ./command/CommandDelete.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;

public interface CommandDelete extends Command, Revertible {

    public static final String KEYWORD = "delete";
    
    public static CommandDelete parseCommandDelete(String text) throws Exception {
        
        CommandDelete commandDelete = null;
        
        if (Parser.matches(text,Parser.PATTERN_NAME) 
                || Parser.matches(text,Parser.PATTERN_INTEGER)) {
            commandDelete = new CommandDeleteItem(text);
            
        } else if (Parser.matches(text,Parser.PATTERN_PROJECT)) {
            commandDelete = new CommandDeleteProject(text);
            
        } else if (Parser.matches(text,Parser.PATTERN_DELETE_INDEX_FROM_PROJECT)) {
            commandDelete = new CommandDeleteFromProject(text);
            
        } else if (Parser.matches(text,Parser.PATTERN_DELETE_PROGRESS)) {
            commandDelete = new CommandDeleteProgress(text);
            
        }
        else {
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandDelete.KEYWORD));
            
        }
        
        
        return commandDelete;

    }
    
}
```
###### ./command/CommandDeleteFromProject.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.Item;
import object.State;
import project.Projects;

public class CommandDeleteFromProject implements CommandDelete {

    private int index;
    private String projectName;
    private Item item;
    
    public CommandDeleteFromProject(String args) {
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_DELETE_INDEX_FROM_PROJECT);
        index = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
    }
    
    public CommandDeleteFromProject(Item item, String projectName) {
        this.item = item;
        this.projectName = projectName;
    }

    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        Projects projectHandler = state.getProjectHandler();
        
        if (projectName == null) {
            if (currentDisplay instanceof CommandViewProjectName) {
                projectName = ((CommandViewProjectName) currentDisplay).getProjectName();
            } else {
                throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
            }
        }
        
        if (item == null) {
            if (currentDisplay instanceof CommandViewProjectName) {
                item = projectHandler.editEvent(index, projectName);
            }
        }
        
        if (item == null) {
            throw new Exception(String.format(CommonHelper.ERROR_PROJECT_NOT_FOUND, projectName));
        } else if (projectHandler.deleteProjectEvent(index, projectName)) {
            return String.format(CommonHelper.SUCCESS_DELETED_FROM_PROJECT, item.getName(), projectName);
        } else {
            throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
        }
    }

    @Override
    public String revert(State state)
            throws Exception {
        Command revertDeleteFromProjectCommand = new CommandAddToProject(item, projectName);
        return revertDeleteFromProjectCommand.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        return new CommandViewProjectName("\"" + projectName + "\"");
    }

}
```
###### ./command/CommandDeleteItem.java
``` java

package command;

import java.util.ArrayList;
import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.Item;
import object.State;
import project.Projects;
import service.ServiceHandler;

public class CommandDeleteItem implements CommandDelete {

    private String itemKey = null;
    private int itemIndex;
    private Item item;
    
    /**
     * Parses the arguments for delete command
     */
    public CommandDeleteItem(String args) throws Exception {
        Matcher matcher;
        
        if (Parser.matches(args,Parser.PATTERN_NAME)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
            itemKey = matcher.group(Parser.TAG_NAME);
        } else if (Parser.matches(args,Parser.PATTERN_INTEGER)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_INTEGER);
            itemIndex = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
        } else {
            assert(false);
        }
    }
    
    /**
     * Constructs command from specified Item object
     */
    public CommandDeleteItem(Item item) {
        this.item = item;
    }
    
    
    public String getItemKey() {
        return itemKey;
    }
    
    /**
     * Executes delete command, returns feedback string
     */
    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        Projects projectHandler = state.getProjectHandler();
        ServiceHandler serviceHandler = state.getServiceHandler();
        
        if (item == null) {
            if (itemKey == null) {
                if (currentDisplay instanceof CommandViewProjectName) {
                    String projectName = ((CommandViewProjectName)currentDisplay).getProjectName();
                    item = projectHandler.editEvent(itemIndex, projectName);
                } else if (currentDisplay instanceof CommandViewDate
                        || currentDisplay instanceof CommandSearch) {
                    item = serviceHandler.viewItemByIndex(itemIndex);
                }
                
                if (item == null) {
                    throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
                }
            } else {
                ArrayList<Item> filteredItem = serviceHandler.search(itemKey);
                
                if (filteredItem.size() == 0) {
                    throw new Exception(String.format(CommonHelper.ERROR_ITEM_NOT_FOUND, itemKey));
                } else if (filteredItem.size() > 1) {
                    return String.format(CommonHelper.ERROR_MULTIPLE_OCCURRENCE, itemKey);
                } else {
                    item = filteredItem.get(0);
                }
            }
        }
        
        // Check if item is inside a project
        String project = projectHandler.searchItem(item);
        
        if (project != null) {
            throw new Exception(String.format(CommonHelper.ERROR_ITEM_INSIDE_PROJECT, project));
        }
        
        serviceHandler.deleteItem(item);
        
        return String.format(CommonHelper.SUCCESS_ITEM_DELETED, item.getName());
    }

    /**
     * Re-add the deleted command
     */
    @Override
    public String revert(State state) throws Exception {
        CommandAddItem revertDeleteCommand = new CommandAddItem(item);
        return revertDeleteCommand.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        if (item == null) {
            return new CommandSearch(itemKey);
        } else if (itemKey == null) {
            // refresh current display if edit by index
            return null;
        } else {
            // display item's date
            return new CommandViewDate(item.getDisplayDateString());
        }
    }

}
```
###### ./command/CommandDeleteProgress.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.State;
import project.Projects;

public class CommandDeleteProgress implements CommandDelete {

    private int index;
    private String projectName;
    
    public CommandDeleteProgress(String args) {
        
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_DELETE_PROGRESS);
        index = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
    }
    
    public CommandDeleteProgress(int index, String projectName) {
        this.index = index;
        this.projectName = projectName;
    }

    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        Projects projectHandler = state.getProjectHandler();
        
        if (projectName == null) {
            if (currentDisplay instanceof CommandViewProjectName) {
                projectName = ((CommandViewProjectName) currentDisplay).getProjectName();
            } else {
                throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
            }
        }
        
        if (projectHandler.deleteProgressMessage(index, projectName)) {
            return CommonHelper.SUCCESS_PROGRESS_DELETED;
        } else {
            throw new Exception(CommonHelper.ERROR_FAIL_DEL_PROGRESS);
        }
    }

    @Override
    public String revert(State state)
            throws Exception {
        // TODO: save old value
        Command revertDeleteProgressCommand = new CommandAddProgress(index, projectName, "");
        return revertDeleteProgressCommand.execute(state);
 
    }

    @Override
    public Displayable getDisplayable() {
        return null;
    }

}
```
###### ./command/CommandDeleteProject.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.State;
import project.Projects;

public class CommandDeleteProject implements CommandDelete {

    private String projectName;
    
    public CommandDeleteProject(String args) {
        
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_PROJECT);
        projectName = matcher.group(Parser.TAG_NAME);
    }

    @Override
    public String execute(State state) throws Exception {
        Projects projectHandler = state.getProjectHandler();
        
        if (projectHandler.deleteProject(projectName)) {
            return String.format(CommonHelper.SUCCESS_PROJECT_DELETED, projectName);
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_PROJECT_NOT_FOUND, projectName));
        }
    }

    @Override
    public String revert(State state)
            throws Exception {
        // TODO: re-add all events inside project
        Command commandAddProject = new CommandAddProject("project \"" + projectName + "\"");
        return commandAddProject.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        return new CommandViewProject();
    }

}
```
###### ./command/CommandEdit.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;

public interface CommandEdit extends Command, Revertible {

    public static final String KEYWORD = "edit";
    
    public static CommandEdit parseCommandEdit(String text) throws Exception {
        
        CommandEdit commandEdit = null;
        
        if (Parser.matches(text,Parser.PATTERN_EDIT_NAME_BY_INDEX) 
                || Parser.matches(text,Parser.PATTERN_EDIT_NAME_BY_KEY) 
                || Parser.matches(text,Parser.PATTERN_EDIT_DATE_TIME_BY_INDEX) 
                || Parser.matches(text,Parser.PATTERN_EDIT_DATE_TIME_BY_KEY)) {
            commandEdit = new CommandEditItem(text);
            
        } else if (Parser.matches(text,Parser.PATTERN_EDIT_PROJECT)) {
            commandEdit = new CommandEditProject(text);
            
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandEdit.KEYWORD));
            
        }
        
        
        return commandEdit;
    }
}
```
###### ./command/CommandEditItem.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;

import java.util.ArrayList;
import java.util.regex.Matcher;

import object.Item;
import object.State;
import project.Projects;
import service.ServiceHandler;


public class CommandEditItem implements CommandEdit {
    
    private String itemKey = null;
    private int itemIndex;
    Item item = null;
    
    private String fieldName;
    private String newValue;
    private String oldValue;
    
    /**
     * Parses the arguments for edit command
     */
    public CommandEditItem(String args) throws Exception {
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_EDIT_DATE_TIME_BY_INDEX);
        
        if (Parser.matches(args,Parser.PATTERN_EDIT_NAME_BY_INDEX)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_EDIT_NAME_BY_INDEX);
            itemIndex = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
            fieldName = matcher.group(Parser.TAG_FIELD);
            newValue = matcher.group(Parser.TAG_NAME);
            
        } else if (Parser.matches(args,Parser.PATTERN_EDIT_NAME_BY_KEY)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_EDIT_NAME_BY_KEY);
            itemKey = matcher.group(Parser.TAG_KEYWORD);
            fieldName = matcher.group(Parser.TAG_FIELD);
            newValue = matcher.group(Parser.TAG_NAME);
            
        } else if (Parser.matches(args,Parser.PATTERN_EDIT_DATE_TIME_BY_INDEX)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_EDIT_DATE_TIME_BY_INDEX);
            itemIndex = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
            fieldName = matcher.group(Parser.TAG_FIELD);
            newValue = matcher.group(Parser.TAG_DATETIME);
            
        } else if (Parser.matches(args,Parser.PATTERN_EDIT_DATE_TIME_BY_KEY)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_EDIT_DATE_TIME_BY_KEY);
            itemKey = matcher.group(Parser.TAG_KEYWORD);
            fieldName = matcher.group(Parser.TAG_FIELD);
            newValue = matcher.group(Parser.TAG_DATETIME);
            
        } else {
            assert(false);
        }
        
    }
    
    /**
     * Constructs this command from specified itemName, fieldName, and newValue
     */
    public CommandEditItem(String itemKey, String fieldName, String newValue) {
        this.itemKey = itemKey;
        this.fieldName = fieldName;
        this.newValue = newValue;
    }
    
    public CommandEditItem(Item item, String fieldName, String newValue) {
        this.item = item;
        this.fieldName = fieldName;
        this.newValue = newValue;
    }    
    
    /**
     * Executes edit command, returns feedback string
     */
    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        Projects projectHandler = state.getProjectHandler();
        ServiceHandler serviceHandler = state.getServiceHandler();
        
        if (item == null) {
            if (itemKey == null) {
                if (currentDisplay instanceof CommandViewProjectName) {
                    String projectName = ((CommandViewProjectName)currentDisplay).getProjectName();
                    item = projectHandler.editEvent(itemIndex, projectName);
                } else if (currentDisplay instanceof CommandViewDate
                        || currentDisplay instanceof CommandSearch) {
                    item = serviceHandler.viewItemByIndex(itemIndex);
                }
                
                if (item == null) {
                    throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
                }
            } else {
                ArrayList<Item> filteredItem = serviceHandler.search(itemKey);
                
                if (filteredItem.size() == 0) {
                    throw new Exception(String.format(CommonHelper.ERROR_ITEM_NOT_FOUND, itemKey));
                } else if (filteredItem.size() > 1) {
                    return String.format(CommonHelper.ERROR_MULTIPLE_OCCURRENCE, itemKey);
                } else {
                    item = filteredItem.get(0);
                }
            }
        }
        
        assert(item != null);
        
        String oldName = item.getName();
        
        oldValue = serviceHandler.editItem(item, fieldName, newValue);
        
        return String.format(CommonHelper.SUCCESS_ITEM_EDITED, oldName, fieldName, newValue);
    }

    /**
     * Reverts to initial value
     */
    @Override
    public String revert(State state) throws Exception {
        Command revertEditCommand = new CommandEditItem(item, fieldName, oldValue);
        return revertEditCommand.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        if (item == null) {
            return new CommandSearch(itemKey);
        } else if (itemKey == null) {
            // refresh current display if edit by index
            return null;
        } else {
            // display item's date
            return new CommandViewDate(item.getDisplayDateString());
        }
    }

}
```
###### ./command/CommandEditProject.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.State;
import project.Projects;

public class CommandEditProject implements CommandEdit {

    private String projectName;
    private String fieldName;
    private String newValue;
    
    public CommandEditProject(String args) {

        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_EDIT_PROJECT);
        
        projectName = matcher.group(Parser.TAG_NAME);
        fieldName = matcher.group(Parser.TAG_FIELD);
        newValue = matcher.group(Parser.TAG_VALUE);
    }
    
    public CommandEditProject(String projectName, String fieldName, String newValue) {
        this.projectName = projectName;
        this.fieldName = fieldName;
        this.newValue = newValue;
    }

    @Override
    public String execute(State state)
            throws Exception {
        Projects projectHandler = state.getProjectHandler();
        if (projectHandler.editProjectName(newValue, projectName)) {
            return String.format(CommonHelper.SUCCESS_PROJECT_EDITED, projectName, newValue);
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_DUPLICATE_PROJECT, newValue));
        }
    }

    @Override
    public String revert(State state)
            throws Exception {
        CommandEditProject commandEditProject = new CommandEditProject(newValue, fieldName, projectName);
        return commandEditProject.execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        return new CommandViewProjectName(newValue);
    }

}
```
###### ./command/CommandExit.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;
import javafx.application.Platform;
import object.State;

public class CommandExit implements Command {
    
    public static final String KEYWORD = "exit";
    
    /**
     * Parses the arguments for exit command
     */
    public CommandExit(String args) throws Exception {
        
        if (Parser.matches(args,Parser.PATTERN_EMPTY));
        else {
            // undo command accepts no arguments
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandUndo.KEYWORD));
        }
        
    }

    /**
     * Executes edit command, returns feedback string
     */
    @Override
    public String execute(State state) throws Exception {
        Platform.exit();
        return "";
    }

    @Override
    public Displayable getDisplayable() {
        return null;
    }
}
```
###### ./command/CommandRedo.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;
import object.State;

public class CommandRedo implements Command {
    
    public static final String KEYWORD = "redo";

    public CommandRedo(String args) throws Exception {
        
        if (Parser.matches(args,Parser.PATTERN_EMPTY));
        else {
            // redo command accepts no arguments
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandUndo.KEYWORD));
        }
        
    }
    
    Revertible redoCommand;

    @Override
    public String execute(State state) throws Exception {
        redoCommand = state.getRedoCommand();
        if (redoCommand == null) {
            throw new Exception(CommonHelper.ERROR_EMPTY_REDO);
        }
        return ((Command) redoCommand).execute(state);
    }

    @Override
    public Displayable getDisplayable() {
        return ((Command) redoCommand).getDisplayable();
    }

}
```
###### ./command/CommandSearch.java
``` java

package command;

import java.util.ArrayList;
import java.util.regex.Matcher;

import ui.GUI;
import helper.CommonHelper;
import helper.Parser;
import javafx.scene.control.Separator;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import object.Event;
import object.Item;
import object.State;
import object.Todo;
import service.ServiceHandler;

public class CommandSearch implements Command, Displayable {

    public static final String KEYWORD = "search";
    
    public static CommandSearch parseCommandSearch(String text) throws Exception {
        
        CommandSearch commandSearch = null;
        
        if (Parser.matches(text, Parser.PATTERN_NAME)) {
            commandSearch = new CommandSearch(text);
            
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandSearch.KEYWORD));
            
        }
        
        return commandSearch;
    }
    
    private String itemKey;
    private ArrayList<Item> filteredItem;

    public ArrayList<Item> getFilteredItem() {
        return filteredItem;
    }

    public CommandSearch(String args) {
        
        if (Parser.matches(args,Parser.PATTERN_NAME)) {
            Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
            itemKey = matcher.group(Parser.TAG_NAME);
        } else {
            itemKey = args;
        }
    }
    
    @Override
    public String execute(State state) throws Exception {
        ServiceHandler serviceHandler = state.getServiceHandler();
        
        filteredItem = serviceHandler.search(itemKey);
        if (!state.isTextMode()) {
            return CommonHelper.SUCCESS_EXECUTED;
        } else {
            return CommonHelper.getFormattedItemList(filteredItem);
        }
    }

    @Override
    public void display(GridPane displayBox) {
        
        displayBox.getChildren().clear();
        
        String previousDate = null;
        
        int rowIndex = 0;
        int listNumber = 0;
        int matchesNumber = filteredItem.size();
        
        displayBox.add(
                GUI.getText(String.format(CommonHelper.FORMAT_SEARCH, matchesNumber),
                Color.GREEN, GUI.FONT_SIZE_TEXT), 
                    0, rowIndex++, 4, 1);
        
        for (Item item : filteredItem) {
            String date;
            if (item instanceof Event) {
                date = ((Event)item).getStartDateString();
            }
            else {
                date = ((Todo)item).getDeadlineDateString();
            }
            
            if (!date.equals(previousDate)) {
                Separator separator = new Separator();
                rowIndex++;
                rowIndex++;
                // create row for date
                Text dateString = null;
                
                if (item instanceof Todo && !((Todo)item).hasDate()) {
                    dateString = GUI.getText(GUI.TEXT_FLOATING_TASK,
                            Color.BLACK, GUI.FONT_SIZE_TITLE);
                }
                else {
                    dateString = GUI.getText(date,
                            Color.BLACK, GUI.FONT_SIZE_TITLE);
                }
                displayBox.add(dateString, 1, rowIndex++, 4, 1);
                displayBox.add(separator, 0, rowIndex++, 4, 1);
            }
            listNumber++;
            
            Text numberingText = GUI.getText(String.valueOf(listNumber),
                    Color.BLACK, GUI.FONT_SIZE_TEXT);
            Text markText;
            
            if (item.getDone()) {
                markText = GUI.getText(GUI.TEXT_CHECK, 
                        Color.GREEN, GUI.FONT_SIZE_TITLE);
            } else {
                markText = GUI.getText(GUI.TEXT_BOX, 
                        Color.GREY, GUI.FONT_SIZE_TITLE);
            }
            
            Text nameText = GUI.getText(item.getName(),
                    Color.GREY, GUI.FONT_SIZE_TEXT);
            
            // get time string for this item
            String timeString = "";
            if (item instanceof Event) {
                timeString += ((Event)item).getStartTimeString();
                timeString += " to ";
                
                if (((Event)item).getEndDateString().equals(date)) {
                    timeString += ((Event)item).getEndTimeString();
                }
                else {
                    timeString += ((Event)item).getEndDateTimeString();
                }
            }
            else {
                if (((Todo)item).hasDate())
                    timeString += ((Todo)item).getDeadlineTimeString();
            }
            

            Text timeText = GUI.getText(timeString,
                    Color.GREY, GUI.FONT_SIZE_TEXT);
            
            displayBox.add(numberingText, 0, rowIndex);
            displayBox.add(markText, 1, rowIndex);
            displayBox.add(nameText, 2, rowIndex);
            displayBox.add(timeText, 3, rowIndex);
            
            rowIndex++;
            previousDate = date;
        }
    }

    @Override
    public Displayable getDisplayable() {
        return this;
    }
    

}
```
###### ./command/CommandSet.java
``` java

package command;

import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.State;
import service.ServiceHandler;

public class CommandSet implements Command {

    public static final String KEYWORD = "set";

    public CommandSet(String args) throws Exception {
        if (Parser.matches(args,Parser.PATTERN_NAME)) {
            Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
            newDirectory = matcher.group(Parser.TAG_NAME);
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandSet.KEYWORD));
            
        }
    }
    
    String newDirectory;

    @Override
    public String execute(State state) throws Exception {
        ServiceHandler serviceHandler = state.getServiceHandler();
        
        if (serviceHandler.changeDirectory(newDirectory)) {
            return String.format(CommonHelper.SUCCESS_SET_DIRECTORY, newDirectory);
        } else {
            throw new Exception(CommonHelper.ERROR_INVALID_PATH);
        }
    }

    @Override
    public Displayable getDisplayable() {
        return null;
    }

}
```
###### ./command/CommandUncheck.java
``` java

package command;

import java.util.ArrayList;
import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import object.Item;
import object.State;
import project.Projects;
import service.ServiceHandler;

public class CommandUncheck implements Command, Revertible {

    public static final String KEYWORD = "uncheck";
    
    private String itemKey = null;
    private int itemIndex;
    private Item item;
    
    public CommandUncheck(String args) throws Exception {
        Matcher matcher;
        
        if (Parser.matches(args,Parser.PATTERN_NAME)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
            itemKey = matcher.group(Parser.TAG_NAME);
        } else if (Parser.matches(args,Parser.PATTERN_INTEGER)) {
            matcher = Parser.matchRegex(args, Parser.PATTERN_INTEGER);
            itemIndex = Integer.parseInt(matcher.group(Parser.TAG_INDEX)) - 1;
        } else {
            // undo command accepts no arguments
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandCheck.KEYWORD));
        }
    }
    
    public CommandUncheck(Item item) {
        this.item = item;
    }

    @Override
    public String execute(State state) throws Exception {
        Displayable currentDisplay = state.getCurrentDisplay();
        Projects projectHandler = state.getProjectHandler();
        ServiceHandler serviceHandler = state.getServiceHandler();
        
        if (item == null) {
            if (itemKey == null) {
                if (currentDisplay instanceof CommandViewProjectName) {
                    String projectName = ((CommandViewProjectName)currentDisplay).getProjectName();
                    item = projectHandler.editEvent(itemIndex, projectName);
                } else if (currentDisplay instanceof CommandViewDate
                        || currentDisplay instanceof CommandSearch) {
                    item = serviceHandler.viewItemByIndex(itemIndex);
                }
                
                if (item == null) {
                    throw new Exception(CommonHelper.ERROR_INDEX_OUT_OF_BOUND);
                }
            } else {
                ArrayList<Item> filteredItem = serviceHandler.search(itemKey);
                
                if (filteredItem.size() == 0) {
                    throw new Exception(String.format(CommonHelper.ERROR_ITEM_NOT_FOUND, itemKey));
                } else if (filteredItem.size() > 1) {
                    return String.format(CommonHelper.ERROR_MULTIPLE_OCCURRENCE, itemKey);
                } else {
                    item = filteredItem.get(0);
                }
            }
        }
        
        if (serviceHandler.unmark(item)) {
            return String.format(CommonHelper.SUCCESS_ITEM_UNCHECKED, item.getName());
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_ALREADY_UNCHECKED, item.getName()));
        }
    }
    

    @Override
    public String revert(State state)
            throws Exception {
        CommandCheck commandCheck = new CommandCheck(item);
        return commandCheck.execute(state);
    }


    @Override
    public Displayable getDisplayable() {
        if (item == null) {
            return new CommandSearch(itemKey);
        } else if (itemKey == null) {
            // refresh current display if edit by index
            return null;
        } else {
            // display item's date
            return new CommandViewDate(item.getDisplayDateString());
        }
    }

}
```
###### ./command/CommandUndo.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;
import object.State;

public class CommandUndo implements Command {

    public static final String KEYWORD = "undo";
    
    /**
     * Parses the arguments for undo command
     */
    public CommandUndo(String args) throws Exception {
        
        if (Parser.matches(args,Parser.PATTERN_EMPTY));
        else {
            // undo command accepts no arguments
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandUndo.KEYWORD));
        }
        
    }
    
    Revertible mostRecent;
    
    /**
     * Executes undo command, returns feedback string
     */
    @Override
    public String execute(State state) throws Exception {
        mostRecent = state.getUndoCommand();
        if (mostRecent == null) {
            throw new Exception(CommonHelper.ERROR_EMPTY_UNDO);
        }
        state.addRedoCommand(mostRecent);
        return mostRecent.revert(state);
    }

    @Override
    public Displayable getDisplayable() {
        return ((Command)mostRecent).getDisplayable();
    }

}
```
###### ./command/CommandView.java
``` java

package command;

import helper.CommonHelper;
import helper.Parser;

public interface CommandView extends Command, Displayable {

    public static final String KEYWORD = "view";
    
    public static CommandView parseCommandView(String text) throws Exception {
        
        CommandView commandView = null;
        if (Parser.matches(text, Parser.PATTERN_VIEW_PROJECT)) {
            commandView = new CommandViewProject();
        } else if (Parser.matches(text, Parser.PATTERN_NAME)) {
            commandView = new CommandViewProjectName(text);
            
        } else if (Parser.matches(text, Parser.PATTERN_DATE) || Parser.matches(text, Parser.PATTERN_EMPTY)) {
            commandView = new CommandViewDate(text);
            
        } else {
            throw new Exception(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandView.KEYWORD));
            
        }
        
        
        return commandView;
    }
    
}
```
###### ./command/CommandViewDate.java
``` java

package command;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.regex.Matcher;

import helper.CalendarHelper;
import helper.CommonHelper;
import helper.Parser;
import javafx.scene.control.Separator;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import object.Item;
import object.State;
import service.ServiceHandler;
import ui.GUI;

public class CommandViewDate implements CommandView {

    
    private static final int TODAY_INDEX = 0;
    private static final int TASK_INDEX = 1;
    private static final String EMPTY_LIST_TEXT = "Nothing to do!";
    
    private String dateString = null;
    private ArrayList< ArrayList<Item> > mergedList;
    
    /**
     * Parses the arguments for view command
     */
    public CommandViewDate(String args) {
        Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_DATE);
        dateString = matcher.group(Parser.TAG_DATE).trim();
    }
    
    public CommandViewDate() {
        dateString = CalendarHelper.getDateString(Calendar.getInstance());
    }

    /**
     * Executes view command, returns feedback string
     */
    @Override
    public String execute(State state) throws Exception {
        ServiceHandler serviceHandler = state.getServiceHandler();
        
        mergedList = serviceHandler.viewMultipleDays(dateString);
        if (!state.isTextMode()) {
            return CommonHelper.SUCCESS_EXECUTED;
        } else {
            String formattedString = "";
            boolean isFirstList = true;
            for (ArrayList<Item> list : mergedList) {
                if (list.isEmpty()) {
                    continue;
                }
                if (isFirstList) {
                    isFirstList = false;
                } else {
                    formattedString += "\n";
                }
                formattedString += CommonHelper.getFormattedItemList(list);
            }
            return formattedString;
        }
    }
    
    @Override
    public void display(GridPane displayBox) {
        displayBox.getChildren().clear();
        
        Calendar date = null;
        try {
            date = CalendarHelper.parseDate(dateString);
        } catch (ParseException e) {
            assert(false);
        }
        
        // start from second row
        int rowIndex = 2;
        int listingNumber = 0;
        
        for (int i = 0; i < mergedList.size(); i++) {
            
            ArrayList<Item> itemList = mergedList.get(i);
            int size = itemList.size();
            String dateString = CalendarHelper.getDateString(date);
            
            // Only display if list not empty or this is today's date
            if (size > 0 || i == TODAY_INDEX) {
            
                Text dateText;
                if (i == TASK_INDEX) {
                    dateText = GUI.getText(GUI.TEXT_FLOATING_TASK, 
                            Color.BLACK, GUI.FONT_SIZE_TITLE);
                } else {
                    dateText = GUI.getText(dateString, 
                            Color.BLACK, GUI.FONT_SIZE_TITLE);
                    
                }
                
                // Add the date header to display box
                displayBox.add(dateText, 1, rowIndex++, 4, 1);
                displayBox.add(new Separator(), 0, rowIndex++, 4, 1);
                
                // Check if empty
                if (size == 0) {
                    
                    Text freeText = GUI.getText(EMPTY_LIST_TEXT, 
                            Color.GREY, GUI.FONT_SIZE_TEXT);
                    displayBox.add(freeText, 1, rowIndex++, 4, 1);
                    
                } else {
                    
                    for (Item item : itemList) {
                        listingNumber++;
                        
                        Text nameText = GUI.getText(item.getName(), 
                                Color.GREY, GUI.FONT_SIZE_TEXT);
                        Text timeText = GUI.getText(item.getTimeStringOn(dateString),
                                Color.GREY, GUI.FONT_SIZE_TEXT);
                        Text numberingText = GUI.getText(String.valueOf(listingNumber),
                                Color.BLACK, GUI.FONT_SIZE_TEXT);
                        
                        Text markText;
                        
                        if (item.getDone()) {
                            markText = GUI.getText(GUI.TEXT_CHECK, 
                                    Color.GREEN, GUI.FONT_SIZE_TITLE);
                        } else {
                            markText = GUI.getText(GUI.TEXT_BOX, 
                                    Color.GREY, GUI.FONT_SIZE_TITLE);
                        }
                        
                        displayBox.add(numberingText, 0, rowIndex);
                        displayBox.add(markText, 1, rowIndex);
                        displayBox.add(nameText, 2, rowIndex);
                        displayBox.add(timeText, 3, rowIndex);
                        rowIndex++;
                        
                    }
                }
                rowIndex++;
                rowIndex++;
            
            }
                
            if (i != TASK_INDEX) {
                date.add(Calendar.DAY_OF_MONTH, 1);
            }
        }
    }

    @Override
    public Displayable getDisplayable() {
        return this;
    }

}
```
###### ./command/CommandViewProject.java
``` java

package command;

import java.util.ArrayList;

import helper.CommonHelper;
import javafx.scene.control.Separator;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import object.State;
import project.Projects;
import ui.GUI;

public class CommandViewProject implements CommandView {

    private ArrayList<String> projectList;
    private ArrayList<Double> progressList;

    @Override
    public String execute(State state) throws Exception {
        Projects projectHandler = state.getProjectHandler();
        projectList = projectHandler.listExistingProjects();
        progressList = new ArrayList<Double>();
        for (String projectName : projectList) {
            progressList.add(projectHandler.progressBar(projectName));
        }
        return CommonHelper.SUCCESS_EXECUTED;
    }

    @Override
    public Displayable getDisplayable() {
        return this;
    }

    @Override
    public void display(GridPane displayBox) {
        displayBox.getChildren().clear();
        
        int rowIndex = 0;
        
        HBox title = new HBox(GUI.getText(GUI.TEXT_PROJECT, Color.PURPLE, GUI.FONT_SIZE_HEADER));
        
        displayBox.add(title, 1, rowIndex++, 5, 1);
        Separator separator = new Separator();
        displayBox.add(separator, 0, rowIndex++, 5, 1);
        
        for (int i = 0; i < projectList.size(); i++) {
            String projectName = projectList.get(i);
            double progress = progressList.get(i);
            
            Text bulletText = GUI.getText(GUI.TEXT_BULLET,
                    Color.GREY, GUI.FONT_SIZE_TITLE);
            Text nameText = GUI.getText(projectName,
                    Color.GREY, GUI.FONT_SIZE_TEXT);
            Text progressText = GUI.getText(String.valueOf(progress)+"%",
                    Color.GREEN, GUI.FONT_SIZE_TEXT);

            displayBox.add(bulletText, 1, rowIndex);
            displayBox.add(nameText, 2, rowIndex);
            displayBox.add(progressText, 3, rowIndex);
            
            rowIndex++;
            
        }

    }

}
```
###### ./command/CommandViewProjectName.java
``` java

package command;

import java.util.ArrayList;
import java.util.regex.Matcher;

import helper.CommonHelper;
import helper.Parser;
import javafx.geometry.Pos;
import javafx.scene.control.Separator;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import object.Event;
import object.State;
import project.Projects;
import ui.GUI;

public class CommandViewProjectName implements CommandView {

    public CommandViewProjectName(String args) {
        if (Parser.matches(args, Parser.PATTERN_NAME)) {
            Matcher matcher = Parser.matchRegex(args, Parser.PATTERN_NAME);
            projectName = matcher.group(Parser.TAG_NAME);
        } else {
            projectName = args;
        }
    }
    
    private String projectName = null;
    private double projectProgress;
    private ArrayList<Event> projectEvents;

    public String getProjectName() {
        return projectName;
    }
    
    @Override
    public String execute(State state) throws Exception {
        Projects projectHandler = state.getProjectHandler();
        projectEvents = projectHandler.viewEventProgressTimeline(projectName);
        if (projectEvents == null) {
            throw new Exception(String.format(CommonHelper.ERROR_PROJECT_NOT_FOUND, projectName));
        }
        projectProgress = projectHandler.progressBar(projectName);
        return CommonHelper.SUCCESS_EXECUTED;
    }

    @Override
    public void display(GridPane displayBox) {
        displayBox.getChildren().clear();
        
        String previousDate = null;
        
        int rowIndex = 0;
        int listNumber = 0;
        HBox title = new HBox(
                GUI.getText(projectName + " (" + String.valueOf(projectProgress)+"%)",
                        Color.ORANGE, GUI.FONT_SIZE_HEADER));
        
        title.setAlignment(Pos.CENTER);
        
        displayBox.add(title, 0, rowIndex++, 5, 1);
        
        for (Event item : projectEvents) {
            listNumber++;
            String date = item.getStartDateString();
            
            if (!date.equals(previousDate)) {
                Separator separator = new Separator();
                rowIndex++;
                rowIndex++;
                
                Text dateString = GUI.getText(date, Color.BLACK, GUI.FONT_SIZE_TITLE);
                
                displayBox.add(dateString, 1, rowIndex++, 5, 1);
                displayBox.add(separator, 0, rowIndex++, 5, 1);
            }
            
            Text markText;
            
            if (item.getDone()) {
                markText = GUI.getText(GUI.TEXT_CHECK, 
                        Color.GREEN, GUI.FONT_SIZE_TITLE);
            } else {
                markText = GUI.getText(GUI.TEXT_BOX, 
                        Color.GREY, GUI.FONT_SIZE_TITLE);
            }
            
            Text nameText;
            Text additionalText = null;
            
            if (!item.getAdditionalInfo().isEmpty()) {
                nameText = GUI.getText(item.getName(),
                        Color.BLACK, GUI.FONT_SIZE_TEXT);
                additionalText = GUI.getText(item.getAdditionalInfo(), 
                        Color.GREY, GUI.FONT_SIZE_TEXT);
                
            } else {
                nameText = GUI.getText(item.getName(), 
                        Color.GREY, GUI.FONT_SIZE_TEXT);
            }
            
            Text numberingText = GUI.getText(String.valueOf(listNumber),
                    Color.BLACK, GUI.FONT_SIZE_TEXT);
            Text timeText = GUI.getText(item.getTimeStringOn(date),
                    Color.GREY, GUI.FONT_SIZE_TEXT);

            displayBox.add(numberingText, 0, rowIndex);
            displayBox.add(markText, 1, rowIndex);
            displayBox.add(nameText, 2, rowIndex);
            displayBox.add(timeText, 3, rowIndex);
            
            rowIndex++;
            
            if (additionalText != null) {
                displayBox.add(additionalText, 2, rowIndex);
                rowIndex++;
            }
            
            previousDate = date;
        }
        
    }
    
    @Override
    public Displayable getDisplayable() {
        return this;
    }

}
```
###### ./command/Displayable.java
``` java

package command;

import javafx.scene.layout.GridPane;

public interface Displayable {
    
    /**
     * Displays information on displayBox
     */
    public void display(GridPane displayBox);
    
}
```
###### ./command/Revertible.java
``` java

package command;

import object.State;

public interface Revertible {

    /**
     * Reverts effect of this command
     */
    public String revert(State state) throws Exception;
}
```
###### ./helper/CalendarHelper.java
``` java

package helper;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class CalendarHelper {
    
    /* Date and time format */
    public static final String PATTERN_DATE = "dd MMM yyyy";
    public static final String PATTERN_TIME = "HH:mm";
    public static final String PATTERN_DATE_TIME = "dd MMM yyyy HH:mm";
    
    public static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat(PATTERN_DATE);
    public static final SimpleDateFormat FORMAT_TIME = new SimpleDateFormat(PATTERN_TIME);
    public static final SimpleDateFormat FORMAT_DATE_TIME = new SimpleDateFormat(PATTERN_DATE_TIME);

    public static final String TYPE_DATE = "date";
    public static final String TYPE_TIME = "time";
    public static final String TYPE_DATE_TIME = "datetime";
    public static final String TODAY = "today";
    public static final String TOMORROW = "tomorrow";
    
    
    /* Calendar Helper functions */
    
    private static String denaturalizeString(String dateTimeString) {
        dateTimeString = dateTimeString.trim();
        
        Calendar today = Calendar.getInstance();
        Calendar tomorrow = Calendar.getInstance();
        tomorrow.add(Calendar.DAY_OF_MONTH, 1);
        
        dateTimeString = dateTimeString.replaceAll(TODAY, getDateString(today));
        dateTimeString = dateTimeString.replaceAll(TOMORROW, getDateString(tomorrow));
        
        return dateTimeString;
    }
    
    /**
     * Returns a Calendar object with parsed timeString as the time
     */
    public static Calendar parseTime(String timeString) throws ParseException {
        FORMAT_TIME.setLenient(false);
        timeString = denaturalizeString(timeString);
        Calendar time = Calendar.getInstance();
        time.setTime(FORMAT_TIME.parse(timeString));
        if (!getTimeString(time).toLowerCase().equals(timeString.toLowerCase())) {
            throw new ParseException(timeString, 0);
        }
        return time;
    }
    
    /**
     * Returns a Calendar object with parsed dateString as the date
     */
    public static Calendar parseDate(String dateString) throws ParseException {
        FORMAT_DATE.setLenient(false);
        dateString = denaturalizeString(dateString);
        Calendar date = Calendar.getInstance();
        date.setTime(FORMAT_DATE.parse(dateString));
        if (!getDateString(date).toLowerCase().equals(dateString.toLowerCase())) {
            throw new ParseException(dateString, 0);
        }
        return date;
    }
    
    /**
     * Returns a Calendar object with parsed dateTimeString as the date and time
     */
    public static Calendar parseDateTime(String dateTimeString) throws ParseException {
        FORMAT_DATE_TIME.setLenient(false);
        dateTimeString = denaturalizeString(dateTimeString);
        Calendar datetime = Calendar.getInstance();
        datetime.setTime(FORMAT_DATE_TIME.parse(dateTimeString));
        if (!getDateTimeString(datetime).toLowerCase().equals(dateTimeString.toLowerCase())) {
            throw new ParseException(dateTimeString, 0);
        }
        return datetime;
    }
    
    /**
     * Update the time of the specified calendar object with parsed timeString. Returns true when timeString is valid, otherwise returns false.
     */
    public static boolean updateTime(Calendar calendar, String timeString) {
        try {
            Calendar time = parseTime(timeString);
            
            calendar.set(Calendar.HOUR_OF_DAY, time.get(Calendar.HOUR_OF_DAY));
            calendar.set(Calendar.MINUTE, time.get(Calendar.MINUTE));
        } catch (ParseException e) {
            return false;
        }
        return true;
    }
    
    /**
     * Update the date of the specified calendar object with parsed dateString. Returns true when dateString is valid, otherwise returns false.
     */
    public static boolean updateDate(Calendar calendar, String dateString) {
        try {
            Calendar date = parseDate(dateString);
            
            calendar.set(Calendar.DATE, date.get(Calendar.DATE));
            calendar.set(Calendar.MONTH, date.get(Calendar.MONTH));
            calendar.set(Calendar.YEAR, date.get(Calendar.YEAR));
        } catch (ParseException e) {
            return false;
        }
        return true;
    }
    
    /**
     * Update the date and time of the specified calendar object with parsed dateTimeString. Returns true when dateTimeString is valid, otherwise returns false.
     */
    public static boolean updateDateTime(Calendar calendar, String dateTimeString) {
        try {
            Calendar date = parseDateTime(dateTimeString);
            
            calendar.set(Calendar.DATE, date.get(Calendar.DATE));
            calendar.set(Calendar.MONTH, date.get(Calendar.MONTH));
            calendar.set(Calendar.YEAR, date.get(Calendar.YEAR));
            calendar.set(Calendar.HOUR_OF_DAY, date.get(Calendar.HOUR_OF_DAY));
            calendar.set(Calendar.MINUTE, date.get(Calendar.MINUTE));
        } catch (ParseException e) {
            return false;
        }
        return true;
    }
    
    /**
     * Update the date and/or time of the specified calendar object with parsed calendarString. Returns true when calendarString is valid, otherwise returns false.
     */
    public static boolean updateCalendar(Calendar calendar, String calendarString) {
        String stringType = getCalendarStringType(calendarString);
        switch (stringType) {
            case (TYPE_DATE_TIME):
                return updateDateTime(calendar, calendarString);
            case (TYPE_DATE):
                return updateDate(calendar, calendarString);
            case (TYPE_TIME):
                return updateTime(calendar, calendarString);
            default:
                return false;
        }
    }
    
    /**
     * Returns date string of the specified calendar object
     */
    public static String getDateString(Calendar calendar) {
        return FORMAT_DATE.format(calendar.getTime());
    }
    
    /**
     * Returns time string of the specified calendar object
     */
    public static String getTimeString(Calendar calendar) {
        return FORMAT_TIME.format(calendar.getTime());
    }
    
    /**
     * Returns date and time string of the specified calendar object
     */
    public static String getDateTimeString(Calendar calendar) {
        return FORMAT_DATE_TIME.format(calendar.getTime());
    }
    
    /**
     * Returns calendar type (TYPE_DATE_TIME, TYPE_DATE, TYPE_TIME) of the specified string
     */
    public static String getCalendarStringType(String calendarString) {
        try {
            parseDateTime(calendarString);
            return TYPE_DATE_TIME;
        } catch (ParseException e) {
            
        }
        try {
            parseDate(calendarString);
            return TYPE_DATE;
        } catch (ParseException e) {
            
        }
        try {
            parseTime(calendarString);
            return TYPE_TIME;
        } catch (ParseException e) {
            
        }
        return null;
    }
    
    public static boolean isCalendarString(String calendarString) {
        return getCalendarStringType(calendarString) != null;
    }
    
}
```
###### ./helper/CommonHelper.java
``` java

package helper;
import java.text.ParseException;
import java.util.ArrayList;

import object.Event;
import object.Item;
import object.Todo;

/*
 * This class contains useful functions and constants
 */

public class CommonHelper {

    /* Prompt messages */
    public static final String MESSAGE_WELCOME = "Welcome to NowGotTime";
    public static final String MESSAGE_PROMPT = "command: ";
    
    /* Success messages */
    public static final String SUCCESS_ITEM_CREATED          = "'%1$s' added";
    public static final String SUCCESS_PROJECT_CREATED       = "project '%1$s' created";
    public static final String SUCCESS_ITEM_DELETED          = "'%1$s' deleted";
    public static final String SUCCESS_PROJECT_DELETED       = "project '%1$s' deleted";
    public static final String SUCCESS_ITEM_EDITED           = "'%1$s' %2$s changed to '%3$s'";
    public static final String SUCCESS_PROJECT_EDITED        = "project '%1$s' changed to '%2$s'";
    public static final String SUCCESS_ADDED_TO_PROJECT      = "'%1$s' added to project '%2$s'";
    public static final String SUCCESS_DELETED_FROM_PROJECT  = "'%1$s' deleted from project '%2$s'";
    public static final String SUCCESS_EXECUTED              = "Got it!";

    public static final String SUCCESS_ITEM_CHECKED          = "marked done '%1$s'";
    public static final String SUCCESS_ITEM_UNCHECKED        = "marked not done '%1$s'";
    public static final String SUCCESS_SET_DIRECTORY         = "save directory moved to '%1$s'";
    public static final String SUCCESS_PROGRESS_ADDED        = "progress added";
    public static final String SUCCESS_PROGRESS_DELETED      = "progress deleted";
    
    
    /* Error messages */
    public static final String ERROR_INVALID_COMMAND     = "unknown command '%1$s'";
    public static final String ERROR_INVALID_ARGUMENTS   = "invalid arguments for command '%1$s'";
    public static final String ERROR_DUPLICATE_PROJECT   = "project '%1$s' already exists";
    public static final String ERROR_MULTIPLE_OCCURRENCE = "multiple occurrence of '%1$s' found";
    public static final String ERROR_START_AFTER_END     = "start of event cannot be after end of event";
    public static final String ERROR_INDEX_OUT_OF_BOUND  = "item with this index does not exists";
    public static final String ERROR_ITEM_NOT_FOUND      = "'%1$s' not found";
    public static final String ERROR_PROJECT_NOT_FOUND   = "project '%1$s' not found";
    public static final String ERROR_EMPTY_UNDO          = "cannot undo any previous command";
    public static final String ERROR_EMPTY_REDO          = "cannot reddo any previous command";
    public static final String ERROR_INVALID_PATH        = "invalid new save directory";
    public static final String ERROR_ALREADY_CHECKED     = "'%1$s' already checked";
    public static final String ERROR_ALREADY_UNCHECKED   = "'%1$s' already unchecked";
    public static final String ERROR_TODO_ON_PROJECT     = "only event can be added to project";
    public static final String ERROR_FAIL_ADD_PROGRESS   = "progress already exist";
    public static final String ERROR_FAIL_DEL_PROGRESS   = "progress doesn't exist";
    public static final String ERROR_ITEM_INSIDE_PROJECT = "cannot delete, item is inside project '%1$s'";
    
    public static final String FORMAT_SEARCH = "Found %1$s item(s):";
    
    public static final String FIELD_NAME     = "name";
    public static final String FIELD_START    = "start";
    public static final String FIELD_END      = "end";
    public static final String FIELD_DUE      = "due";
    
    /* String Manipulation Helper functions */
    
    /**
     * Returns first word of the specified text
     * @param text a non-empty string
     * @return the first word of the specified text
     */
    public static String getFirstWord(String text) {
        // Find the first whitespace position
        int spacePosition = text.indexOf(' ');
        if (spacePosition > -1) {
            return text.substring(0, spacePosition);
        }
        else {
            return text;
        }
    }
    
    /**
     * Returns a text with its first word removed
     * @param text a non-empty string
     * @return text without the first word
     */
    public static String removeFirstWord(String text) {
        String firstWord = getFirstWord(text);
        return text.substring(firstWord.length());
    }
    
    /**
     * Returns a formatted list of events
     * @param eventList list of events
     * @param dateString a valid date string
     * @return formatted list of events
     */
    public static String getFormattedEventList(ArrayList<Event> eventList, String dateString) throws ParseException {
        StringBuilder formattedString = new StringBuilder();
        
        for (Event event : eventList) {
            formattedString.append(event.toFormattedString(dateString));
            formattedString.append("\n");
        }
        
        return formattedString.toString();
    }
    
    /**
     * Returns a formatted list of todos
     * @param todoList list of todos
     * @param dateString a valid date string
     * @return formatted list of todos
     */
    public static String getFormattedTodoList(ArrayList<Todo> todoList, String dateString) throws ParseException {
        StringBuilder formattedString = new StringBuilder();
        
        for (Todo todo : todoList) {
            formattedString.append(todo.toFormattedString(dateString));
            formattedString.append("\n");
        }
        
        return formattedString.toString();
    }
    
    public static String getFormattedItemList(ArrayList<Item> list) throws ParseException {
        StringBuilder formattedString = new StringBuilder();
        
        for (Item item : list) {
            formattedString.append(item.toFormattedString());
            formattedString.append("\n");
        }
        
        return formattedString.toString();
    }
    
    
    
}
```
###### ./helper/Parser.java
``` java

package helper;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Parser {
    
    // "<name>" on <start> to <end>
    public static final String PATTERN_ADD_EVENT                 = "\\s*\"(?<name>.+)\"\\s+from (?<start>.+) to (?<end>.+)\\s*";
    // "<name>" on <due>
    public static final String PATTERN_ADD_TASK                  = "\\s*\"(?<name>.+)\"\\s+by (?<datetime>.+)\\s*";
    // project "<name>"
    public static final String PATTERN_PROJECT                   = "\\s*project\\s+\"(?<name>.+)\"\\s*";
    // "<keyword>" to "<name>"
    public static final String PATTERN_ADD_KEYWORD_TO_PROJECT    = "\\s*\"(?<keyword>.+)\"\\s+to\\s+\"(?<name>.+)\"\\s*";
    // <index> to "<name>"
    public static final String PATTERN_ADD_INDEX_TO_PROJECT      = "\\s*(?<index>\\d+)\\s+to\\s+\"(?<name>.+)\"\\s*";
    // progress <index> "<progress>"
    public static final String PATTERN_ADD_PROGRESS              = "\\s*progress\\s+(?<index>\\d+)\\s+\"(?<progress>.+)\"\\s*";
    // <index> from project
    public static final String PATTERN_DELETE_INDEX_FROM_PROJECT = "\\s*(?<index>\\d+)\\s+from\\s+project\\s*";
    // progress <index>
    public static final String PATTERN_DELETE_PROGRESS           = "\\s*progress\\s+(?<index>\\d+)\\s*";
    // "<keyword>" <field>(name) "<name>"
    public static final String PATTERN_EDIT_NAME_BY_KEY          = "\\s*\"(?<keyword>.+)\"\\s+(?<field>name)\\s+\"(?<name>.+)\"\\s*";
    // "<keyword>" <field>(start|end|due) <date>
    public static final String PATTERN_EDIT_DATE_TIME_BY_KEY     = "\\s*\"(?<keyword>.+)\"\\s+(?<field>start|end|due)\\s+(?<datetime>.+)\\s*";
    // <index> <field>(name) "<name>"
    public static final String PATTERN_EDIT_NAME_BY_INDEX        = "\\s*(?<index>\\d+)\\s+(?<field>name)\\s+\"(?<name>.+)\"\\s*";
    // <index> <field>(start|end|due) <date>
    public static final String PATTERN_EDIT_DATE_TIME_BY_INDEX   = "\\s*(?<index>\\d+)\\s+(?<field>start|end|due)\\s+(?<datetime>.+)\\s*";
    // project "<name>" <field>(name) "<value>"
    public static final String PATTERN_EDIT_PROJECT              = "\\s*project\\s+\"(?<name>.+)\"\\s+(?<field>name)\\s+\"(?<value>.+)\"\\s*";
    // project
    public static final String PATTERN_VIEW_PROJECT              = "\\s*project\\s*";
    // "<name>"
    public static final String PATTERN_NAME                      = "\\s*\"(?<name>.+)\"\\s*"; 
    // <index>
    public static final String PATTERN_INTEGER                   = "\\s*(?<index>\\d+)\\s*"; 
    // <value>
    public static final String PATTERN_ANY                       = "\\s*(?<value>.+)\\s*";  
    // <value>
    public static final String PATTERN_DATE                      = "\\s*(?<date>.+)\\s*";  
    // ~empty~
    public static final String PATTERN_EMPTY                     = "\\s*";

    // String
    public static final String TAG_NAME     = "name";
    public static final String TAG_VALUE    = "value";
    public static final String TAG_KEYWORD  = "keyword";
    public static final String TAG_PROGRESS = "progress";
    public static final String TAG_FIELD    = "field";
    
    // Integer
    public static final String TAG_INDEX    = "index";
    
    // Date
    public static final String TAG_START    = "start";
    public static final String TAG_END      = "end";
    public static final String TAG_DATE     = "date";
    public static final String TAG_DATETIME = "datetime";
    
    public static Matcher matchRegex(String args, String patternString) {
        Pattern regex = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
        Matcher regexMatcher = regex.matcher(args);
        if (regexMatcher.matches()) {
            
            // check if valid calendar string
            try {
                if (!CalendarHelper.isCalendarString(regexMatcher.group(TAG_START))) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (!CalendarHelper.isCalendarString(regexMatcher.group(TAG_END))) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (!CalendarHelper.isCalendarString(regexMatcher.group(TAG_DATETIME))) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (CalendarHelper.getCalendarStringType(regexMatcher.group(TAG_DATE)) != CalendarHelper.TYPE_DATE) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (regexMatcher.group(TAG_NAME).length() > 60) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (regexMatcher.group(TAG_KEYWORD).length() > 60) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (regexMatcher.group(TAG_VALUE).length() > 60) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            try {
                if (regexMatcher.group(TAG_PROGRESS).length() > 60) {
                    return null;
                }
            } catch (IllegalArgumentException iae) {
            }
            
            return regexMatcher;
        }
        else {
            return null;
        }
    }
    
    public static boolean matches(String args, String patternString) {
        return (matchRegex(args, patternString) != null);
    }
}
```
###### ./object/State.java
``` java

package object;

import java.util.Stack;

import command.Command;
import command.CommandViewDate;
import command.Displayable;
import command.Revertible;
import javafx.scene.layout.GridPane;
import project.Projects;
import service.ServiceHandler;

public class State {

    private ServiceHandler serviceHandler = null;
    private Projects projectHandler = null;

    private Stack<Revertible> undoStack;
    private Stack<Revertible> redoStack;
    private Displayable currentDisplay;
    
    private boolean textMode;
    
    public boolean isTextMode() {
        return textMode;
    }

    public State(boolean textMode) {
        serviceHandler = new ServiceHandler();
        projectHandler = new Projects();
        undoStack = new Stack<Revertible>();
        redoStack = new Stack<Revertible>();
        currentDisplay = new CommandViewDate();
        this.textMode = textMode;
    }
    
    public State() {
        this(true);
    }
    
    
    
    public ServiceHandler getServiceHandler() {
        return serviceHandler;
    }

    public Projects getProjectHandler() {
        return projectHandler;
    }
    
    public Revertible getUndoCommand() {
        if (undoStack.isEmpty()) {
            return null;
        } else {
            return undoStack.pop();
        }
    }
    
    public Revertible getRedoCommand() {
        if (redoStack.isEmpty()) {
            return null;
        } else {
            return redoStack.pop();
        }
    }
    
    public void addUndoCommand(Revertible command) {
        undoStack.push(command);
    }
    
    public void addRedoCommand(Revertible command) {
        redoStack.push(command);
    }
    
    public void clearRedoStack() {
        redoStack.clear();
    }
    
    public void updateDisplay(Displayable newDisplay) {
        if (newDisplay != null) {
            currentDisplay = newDisplay;
        }
    }
    
    public Displayable getCurrentDisplay() {
        return currentDisplay;
    }
    
    public boolean showCurrentDisplay(GridPane displayBox) {
        if (currentDisplay != null) {
            try {
                ((Command)currentDisplay).execute(this);
            } catch (Exception e) {
                return false;
            }
            currentDisplay.display(displayBox);
            return true;
        } else {
            return false;
        }
    }

}
```
###### ./test/command/CommandAddProjectTest.java
``` java
package test.command;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import command.CommandAddProject;
import project.Projects;

public class CommandAddProjectTest extends CommandTest {

    @Before
    public void setUp() throws Exception {
        super.setUp();
    }

    @Test
    public void testCanAddProject() {
        String projectName = "yo la yo";
        String commandString = "project \"" + projectName + "\"";
        CommandAddProject command = new CommandAddProject(commandString);
        try {
            command.execute(state);
            Projects projectHandler = state.getProjectHandler();
            assertEquals(1, projectHandler.listExistingProjects().size());
            assertEquals(projectName, projectHandler.listExistingProjects().get(0));
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }
    
    @Test
    public void testCannotAddMultipleProjectWithSameName() {
        String projectName = "yo la yo";
        addProject(projectName);
        
        String commandString = "project \"" + projectName + "\"";
        CommandAddProject command = new CommandAddProject(commandString);
        try {
            command.execute(state);
            fail(EXCEPTION_SHOULD_BE_THROWN);
        } catch (Exception e) {
            Projects projectHandler = state.getProjectHandler();
            assertEquals(1, projectHandler.listExistingProjects().size());
            assertEquals(projectName, projectHandler.listExistingProjects().get(0));
        }
    }

}
```
###### ./test/command/CommandAddTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Test;

import command.CommandAdd;
import command.CommandAddItem;
import helper.CommonHelper;
import object.Event;
import object.Item;
import object.Todo;

public class CommandAddTest extends CommandTest {

    /* parsing test for command add */
    
    public void testParseEvent(String args, String expectedName, String expectedStartDate, String expectedStartTime,
            String expectedEndDate, String expectedEndTime) {
        try {
            CommandAddItem cmd = new CommandAddItem(args);
            Item item = cmd.getItem();
            assertTrue(item instanceof Event); 
            assertEquals(((Event) item).getName(), expectedName);
            assertEquals(((Event) item).getStartDateString(), expectedStartDate);
            assertEquals(((Event) item).getStartTimeString(), expectedStartTime);
            assertEquals(((Event) item).getEndDateString(), expectedEndDate);
            assertEquals(((Event) item).getEndTimeString(), expectedEndTime);
        } catch (Exception e) {
            fail("exception should not be thrown");
        }
    }
    
    public void testParseTodo(String args, String expectedName, String expectedDeadlineDate, String expectedDeadlineTime) {
        try {
            CommandAddItem cmd = new CommandAddItem(args);
            Item item = cmd.getItem();
            assertTrue(item instanceof Todo); 
            assertEquals(((Todo) item).getName(), expectedName);
            assertEquals(((Todo) item).getDeadlineDateString(), expectedDeadlineDate);
            assertEquals(((Todo) item).getDeadlineTimeString(), expectedDeadlineTime);
        } catch (Exception e) {
            fail("exception should not be thrown");
        }
    }
    
    public void testParseFloatingTodo(String args, String expectedName) {
        try {
            CommandAddItem cmd = new CommandAddItem(args);
            Item item = cmd.getItem();
            assertTrue(item instanceof Todo); 
            assertEquals(((Todo) item).getName(), expectedName);
        } catch (Exception e) {
            fail("exception should not be thrown");
        }
    }
    
    @Test
    public void testCannotParseInvalidFormat() {
        try {
            // cannot parse invalid format
            String args = " eat again ";
            CommandAdd.parseCommandAdd(args);
            fail("exception should be thrown");
        } catch (Exception e) {
            assertEquals(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandAddItem.KEYWORD), e.getMessage());
        }
    }
    
    @Test
    public void testCanParseEvent() {
        // Can parse valid format
        testParseEvent("\"eat again!\" from 21 Sep 2016 10:00 to 22 Sep 2016 23:00",
                "eat again!", "21 Sep 2016", "10:00", "22 Sep 2016", "23:00");
        // Can parse valid format with whitespace
        testParseEvent("  \"eat again!\"  from  21 Sep 2016 10:00 to  22 Sep 2016 23:00  ",
                "eat again!", "21 Sep 2016", "10:00", "22 Sep 2016", "23:00");   
    }
    
    @Test
    public void testCanParseTodo() {
        // Can parse valid format
        testParseTodo("\"eat again\" by 21 Sep 2016 10:00",
                "eat again", "21 Sep 2016", "10:00");
        // Can parse valid format with whitespace
        testParseTodo("  \"eat again\"   by   21 Sep 2016 10:00  ",
                "eat again", "21 Sep 2016", "10:00");
    }
    
    @Test
    public void testCanParseFloatingTodo() {
        // Can parse valid format
        testParseFloatingTodo("\"eat again!\"",
                "eat again!");
        // Can parse valid format with whitespace
        testParseFloatingTodo("  \"eat again!\"  ",
                "eat again!");
    }
    
    /* execution test */
    
    @Test
    public void testCanAddEvent() throws Exception {
        String name = "eat again";
        String startDateTime = "21 Sep 2016 10:00";
        String endDateTime = "22 Sep 2016 23:00";
        Event event = new Event(name, startDateTime, endDateTime);
        CommandAddItem command = new CommandAddItem(event);
        String feedback = command.execute(state);
        
        // The feedback message should be success
        assertEquals(feedback, String.format(CommonHelper.SUCCESS_ITEM_CREATED, name));
        // The added event should be the same event
        assertEquals(state.getServiceHandler().viewSpecificEvent(name), event);
    }
    
    @Test
    public void testCanAddTodo() throws Exception {
        String name = "eat again";
        String deadlineDateTime = "21 Sep 2016 10:00";
        Todo todo = new Todo(name, deadlineDateTime);
        CommandAddItem command = new CommandAddItem(todo);
        String feedback = command.execute(state);
        
        // The feedback message should be success
        assertEquals(feedback, String.format(CommonHelper.SUCCESS_ITEM_CREATED, name));
        // The added todo should be the same todo
        assertEquals(state.getServiceHandler().viewSpecificTask(name), todo);
    }
    
    @Test
    public void testCanAddFloatingTodo() throws Exception {
        String name = "eat again";
        Todo todo = new Todo(name);
        CommandAddItem command = new CommandAddItem(todo);
        String feedback = command.execute(state);
        
        // The feedback message should be success
        assertEquals(feedback, String.format(CommonHelper.SUCCESS_ITEM_CREATED, name));
        // The added todo should be the same todo
        assertEquals(state.getServiceHandler().viewSpecificTask(name), todo);
    }

}
```
###### ./test/command/CommandAddToProjectTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import command.CommandAddToProject;
import helper.CommonHelper;
import project.Projects;

public class CommandAddToProjectTest extends CommandTest {

    String projectName;
    
    @Before
    public void setUp() throws Exception {
        super.setUp();
        projectName = "yo la yo";
        addProject(projectName);
    }

    @Test
    public void testCanAddEventToProject() {
        try {
            
            addEvent(EVENT1);
            
            String commandString = "\"" + EVENT1.getName() + "\" to \"" + projectName + "\"";
            
            CommandAddToProject command = new CommandAddToProject(commandString);
            command.execute(state);
            
            Projects projectHandler = state.getProjectHandler();
            
            assertEquals(1, projectHandler.listExistingProjects().size());
            assertEquals(1, projectHandler.viewEventProgressTimeline(projectName).size());
            
            
            
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }
    
    @Test
    public void testCannotAddEventToNonExistingProject() {
        try {
            
            addEvent(EVENT1);
            
            String commandString = "\"" + EVENT1.getName() + "\" to \"" + projectName + "5\"";
            
            CommandAddToProject command = new CommandAddToProject(commandString);
            command.execute(state);
            
            Projects projectHandler = state.getProjectHandler();
            
            assertEquals(1, projectHandler.listExistingProjects().size());
            assertEquals(0, projectHandler.viewEventProgressTimeline(projectName).size());
            
            
            
        } catch (Exception e) {
            assertEquals(String.format(CommonHelper.ERROR_PROJECT_NOT_FOUND, projectName + "5"),
                    e.getMessage());
        }
    }
    
    @Test
    public void testCannotAddTodoToProject() {
        try {
            
            addTodo(TASK1);
            
            String commandString = "\"" + TASK1.getName() + "\" to \"" + projectName + "\"";
            
            CommandAddToProject command = new CommandAddToProject(commandString);
            command.execute(state);
            
            Projects projectHandler = state.getProjectHandler();
            
            assertEquals(1, projectHandler.listExistingProjects().size());
            assertEquals(0, projectHandler.viewEventProgressTimeline(projectName).size());
            
            
            
        } catch (Exception e) {
            assertEquals(CommonHelper.ERROR_TODO_ON_PROJECT, e.getMessage());
        }
    }

}
```
###### ./test/command/CommandDeleteFromProjectTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import command.CommandDeleteFromProject;
import command.CommandViewProjectName;
import project.Projects;

public class CommandDeleteFromProjectTest extends CommandTest {

    String projectName;
    
    @Before
    public void setUp() throws Exception {
        super.setUp();
        projectName = "yo la yo";
        addProject(projectName);
        addEvent(EVENT1);
        addToProject(EVENT1, projectName);
        state.updateDisplay(new CommandViewProjectName(projectName));
    }

    @Test
    public void testCanDeleteEventFromProject() {
        try {
            Projects projectHandler = state.getProjectHandler();
            
            assertEquals(1, projectHandler.viewEventProgressTimeline(projectName).size());
            
            String commandString = "1 from project";
            
            CommandDeleteFromProject command = new CommandDeleteFromProject(commandString);
            command.execute(state);
            
            assertEquals(0, projectHandler.viewEventProgressTimeline(projectName).size());
            
            
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }
    
    @Test
    public void testCannotDeleteNonExistingEventFromProject() {
        Projects projectHandler = state.getProjectHandler();
        try {
            
            assertEquals(1, projectHandler.viewEventProgressTimeline(projectName).size());
            
            String commandString = "2 from project";
            
            CommandDeleteFromProject command = new CommandDeleteFromProject(commandString);
            command.execute(state);
            fail(EXCEPTION_SHOULD_BE_THROWN);
            
        } catch (Exception e) {
            assertEquals(1, projectHandler.viewEventProgressTimeline(projectName).size());
        }
    }

}
```
###### ./test/command/CommandDeleteProjectTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import command.CommandDeleteProject;
import project.Projects;

public class CommandDeleteProjectTest extends CommandTest {

    String projectName;
    
    @Before
    public void setUp() throws Exception {
        super.setUp();
        projectName = "yo la yo";
        addProject(projectName);
    }

    @Test
    public void testCanDeleteProject() {
        String projectName = "yo la yo";
        String commandString = "project \"" + projectName + "\"";
        CommandDeleteProject command = new CommandDeleteProject(commandString);
        try {
            command.execute(state);
            Projects projectHandler = state.getProjectHandler();
            assertEquals(0, projectHandler.listExistingProjects().size());
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }
    
    @Test
    public void testCannotDeleteNonExistingProject() {
        String projectName2 = "yo la yo2";
        String commandString = "project \"" + projectName2 + "\"";
        CommandDeleteProject command = new CommandDeleteProject(commandString);
        try {
            command.execute(state);
            fail(EXCEPTION_SHOULD_BE_THROWN);
        } catch (Exception e) {
            Projects projectHandler = state.getProjectHandler();
            assertEquals(1, projectHandler.listExistingProjects().size());
        }
    }
    

}
```
###### ./test/command/CommandDeleteTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Test;

import command.CommandDeleteItem;
import helper.CommonHelper;

public class CommandDeleteTest extends CommandTest {
    
    /* execution test for delete command */
    
    @Test
    public void testCanDeleteEvent() throws Exception {
        String name = "eat again";
        String startDateTime = "21 Sep 2016 10:00";
        String endDateTime = "22 Sep 2016 23:00";
        addEvent(name, startDateTime, endDateTime);
        
        CommandDeleteItem cmd = new CommandDeleteItem("\"" + name + "\"");
        
        // new event exists on service
        assertNotNull(state.getServiceHandler().viewSpecificEvent(name));
        
        String feedback = cmd.execute(state);

        // successfully deleted
        assertEquals(feedback, String.format(CommonHelper.SUCCESS_ITEM_DELETED, name));
        

        // new event removed from the service
        assertNull(state.getServiceHandler().viewSpecificEvent(name));
        
    }
    
    @Test
    public void testCanDeleteTodo() throws Exception {
        String name = "eat again";
        String deadlineDateTime = "21 Sep 2016 10:00";
        addTodo(name, deadlineDateTime);
        
        CommandDeleteItem cmd = new CommandDeleteItem("\"" + name + "\"");
        
        // new todo exists on service
        assertNotNull(state.getServiceHandler().viewSpecificTask(name));
        
        String feedback = cmd.execute(state);

        // successfully deleted
        assertEquals(feedback, String.format(CommonHelper.SUCCESS_ITEM_DELETED, name));
        

        // new todo removed from the service
        assertNull(state.getServiceHandler().viewSpecificTask(name));
    }
    
    @Test
    public void testCanDeleteFloatingTodo() throws Exception {
        String name = "eat again";
        addTodo(name);
        
        CommandDeleteItem cmd = new CommandDeleteItem("\"" + name + "\"");
        
        // new todo exists on service
        assertNotNull(state.getServiceHandler().viewSpecificTask(name));
        
        String feedback = cmd.execute(state);

        // successfully deleted
        assertEquals(feedback, String.format(CommonHelper.SUCCESS_ITEM_DELETED, name));
        

        // new todo removed from the service
        assertNull(state.getServiceHandler().viewSpecificTask(name));
    }
}
```
###### ./test/command/CommandEditProjectTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import command.CommandEditProject;
import project.Projects;

public class CommandEditProjectTest extends CommandTest {

    String projectName;
    
    @Before
    public void setUp() throws Exception {
        super.setUp();
        projectName = "yo la yo";
        addProject(projectName);
    }

    @Test
    public void testCanEditProject() {
        String projectName2 = "yo la";
        String commandString = "project \"" + projectName + "\" name \"" + projectName2 + "\"";
        CommandEditProject command = new CommandEditProject(commandString);
        try {
            command.execute(state);
            Projects projectHandler = state.getProjectHandler();
            assertEquals(1, projectHandler.listExistingProjects().size());
            assertEquals(projectName2, projectHandler.listExistingProjects().get(0));
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }
    
    @Test
    public void testCannotEditToAnExistingProjectName() {
        String projectName2 = "yo la";
        addProject(projectName2);
        String commandString = "project \"" + projectName + "\" name \"" + projectName2 + "\"";
        CommandEditProject command = new CommandEditProject(commandString);
        try {
            command.execute(state);
            fail(EXCEPTION_SHOULD_BE_THROWN);
        } catch (Exception e) {
            Projects projectHandler = state.getProjectHandler();
            assertEquals(2, projectHandler.listExistingProjects().size());
        }
    }

}
```
###### ./test/command/CommandEditTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Test;

import command.CommandEditItem;
import helper.CommonHelper;
import object.Event;
import object.Todo;

public class CommandEditTest extends CommandTest {

    
    /* execution test for edit command */
    
    @Test
    public void testCanEditEvent() throws Exception {
        String name = "eat again";
        String startDateTime = "21 Sep 2016 10:00";
        String endDateTime = "22 Sep 2016 23:00";
        addEvent(name, startDateTime, endDateTime);
        Event event = null;
        
        // test can edit start date
        new CommandEditItem(name, CommonHelper.FIELD_START, "19 Jan 2016").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getStartDateTimeString(), "19 Jan 2016 10:00");
        
        // test can edit start time
        new CommandEditItem(name, CommonHelper.FIELD_START, "13:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getStartDateTimeString(), "19 Jan 2016 13:00");
        
        // test can edit start date and time
        new CommandEditItem(name, CommonHelper.FIELD_START, "20 Sep 2016 13:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getStartDateTimeString(), "20 Sep 2016 13:00");
        
        // test can edit end date
        new CommandEditItem(name, CommonHelper.FIELD_END, "19 Dec 2016").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getEndDateTimeString(), "19 Dec 2016 23:00");
        
        // test can edit end time
        new CommandEditItem(name, CommonHelper.FIELD_END, "13:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getEndDateTimeString(), "19 Dec 2016 13:00");
        
        // test can edit end date and time
        new CommandEditItem(name, CommonHelper.FIELD_END, "20 Nov 2016 15:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getEndDateTimeString(), "20 Nov 2016 15:00");
        
        // test can edit name
        new CommandEditItem(name, CommonHelper.FIELD_NAME, "eat meh").execute(state);
        assertNull(state.getServiceHandler().viewSpecificEvent(name));
        assertNotNull(state.getServiceHandler().viewSpecificEvent("eat meh"));
        
    }
    
    @Test
    public void testCanEditEventUsingText() throws Exception {
        String name = "eat again";
        String startDateTime = "21 Sep 2016 10:00";
        String endDateTime = "22 Sep 2016 23:00";
        addEvent(name, startDateTime, endDateTime);
        Event event = null;
        
        // test can edit start date
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_START + " 19 Jan 2016").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getStartDateTimeString(), "19 Jan 2016 10:00");
        
        // test can edit start time
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_START + " 13:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getStartDateTimeString(), "19 Jan 2016 13:00");
        
        // test can edit start date and time
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_START + " 20 Sep 2016 13:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getStartDateTimeString(), "20 Sep 2016 13:00");
        
        // test can edit end date
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_END + " 19 Dec 2016").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getEndDateTimeString(), "19 Dec 2016 23:00");
        
        // test can edit end time
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_END + " 13:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getEndDateTimeString(), "19 Dec 2016 13:00");
        
        // test can edit end date and time
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_END + " 20 Nov 2016 15:00").execute(state);
        event = state.getServiceHandler().viewSpecificEvent(name);
        assertEquals(event.getEndDateTimeString(), "20 Nov 2016 15:00");
        
        // test can edit name
        new CommandEditItem("\"" + name + "\" " + CommonHelper.FIELD_NAME + " \"eat meh\"").execute(state);
        assertNull(state.getServiceHandler().viewSpecificEvent(name));
        assertNotNull(state.getServiceHandler().viewSpecificEvent("eat meh"));
        
    }
    
    @Test
    public void testCanEditTodo() throws Exception {
        String name = "eat again lho";
        String deadlineDateTime = "21 Sep 2016 10:00";
        addTodo(name, deadlineDateTime);
        Todo todo = null;
        
        // test can edit due date
        new CommandEditItem(name, CommonHelper.FIELD_DUE, "19 Dec 2016").execute(state);
        todo = state.getServiceHandler().viewSpecificTask(name);
        assertEquals(todo.getDeadlineDateTimeString(), "19 Dec 2016 10:00");
        
        // test can edit due time
        new CommandEditItem(name, CommonHelper.FIELD_DUE, "13:00").execute(state);
        todo = state.getServiceHandler().viewSpecificTask(name);
        assertEquals(todo.getDeadlineDateTimeString(), "19 Dec 2016 13:00");
        
        // test can edit due date and time
        new CommandEditItem(name, CommonHelper.FIELD_DUE, "20 Nov 2016 13:00").execute(state);
        todo = state.getServiceHandler().viewSpecificTask(name);
        assertEquals(todo.getDeadlineDateTimeString(), "20 Nov 2016 13:00");
        
        // test can edit name
        new CommandEditItem(name, CommonHelper.FIELD_NAME, "eat meh meh").execute(state);
        assertNull(state.getServiceHandler().viewSpecificTask(name));
        assertNotNull(state.getServiceHandler().viewSpecificTask("eat meh meh"));
    }
    
    @Test
    public void testCanEditFloatingTodo() throws Exception {
        String name = "eat again lho";
        addTodo(name);
        
        new CommandEditItem(name, CommonHelper.FIELD_NAME, "eat meh meh").execute(state);
        assertNull(state.getServiceHandler().viewSpecificTask(name));
        assertNotNull(state.getServiceHandler().viewSpecificTask("eat meh meh"));
    }
    
   

}
```
###### ./test/command/CommandSearchTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import command.CommandSearch;

public class CommandSearchTest extends CommandTest {

    @Before
    public void setUp() throws Exception {
        super.setUp();
        addEvent(EVENT1);
        addEvent(EVENT2);
        addEvent(EVENT3);
        addEvent(EVENT4);
        addTodo(TASK1);
        addTodo(TASK2);
        addTodo(FLOATING);
    }

    @Test
    public void testCanSearchItem() {
        String keyword = "la";
        String commandString = "\"" + keyword + "\"";
        CommandSearch command = new CommandSearch(commandString);
        try {
            command.execute(state);
            assertEquals(4, command.getFilteredItem().size());
            assertEquals(EVENT1, command.getFilteredItem().get(0));
            assertEquals(EVENT3, command.getFilteredItem().get(1));
            assertEquals(EVENT4, command.getFilteredItem().get(2));
            assertEquals(FLOATING, command.getFilteredItem().get(3));
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }
    
    @Test
    public void testCanSearchWithoutQuote() {
        String keyword = "laadjklas";
        String commandString = "" + keyword + "";
        CommandSearch command = new CommandSearch(commandString);
        try {
            command.execute(state);
            assertEquals(0, command.getFilteredItem().size());
        } catch (Exception e) {
            e.printStackTrace();
            fail(EXCEPTION_SHOULD_NOT_BE_THROWN);
        }
    }

}
```
###### ./test/command/CommandTest.java
``` java

package test.command;


import org.junit.Before;

import object.Event;
import object.State;
import object.Todo;
import project.Projects;
import command.Command;
import command.CommandAddItem;
import storage.FileHandler;

public class CommandTest {
    
    State state;
    
    protected Event EVENT1;
    protected Event EVENT2;
    protected Event EVENT3;
    protected Event EVENT4;
    protected Todo TASK1;
    protected Todo TASK2;
    protected Todo FLOATING;
    protected static final String EXCEPTION_SHOULD_NOT_BE_THROWN = "exception should not be thrown";
    protected static final String EXCEPTION_SHOULD_BE_THROWN = "exception should be thrown";

    
    @Before
    public void setUp() throws Exception {
        FileHandler clear = new FileHandler();
        clear.clearAll();
        state = new State(false);
        
        EVENT1 = new Event("lala", "05 Dec 2015 10:00", "07 Dec 2015 13:00");
        EVENT2 = new Event("lolo", "08 Dec 2015 18:00", "08 Dec 2015 19:00");
        EVENT3 = new Event("yo la", "08 Dec 2015 10:00", "13 Dec 2015 23:50");
        EVENT4 = new Event("yo la", "08 Dec 2015 10:10", "13 Dec 2015 23:50");
        TASK1 = new Todo("eat lo2", "13 Nov 2015 13:00");
        TASK2 = new Todo("eat lo", "18 Nov 2015 14:00");
        FLOATING = new Todo("lala");
    }
    
    public void addTodo(String name) throws Exception {
        String args = "\"" + name + "\"";
        CommandAddItem cmd = new CommandAddItem(args);
        cmd.execute(state);
        
    }
    
    public void addTodo(String name, String deadlineDateTime) throws Exception {
        String args = "\"" + name + "\" by " + deadlineDateTime;
        CommandAddItem cmd = new CommandAddItem(args);
        cmd.execute(state);
    }
    
    public void addEvent(String name, String startDateTime, String endDateTime) throws Exception {
        String args = "\"" + name + "\" from " + startDateTime + " to " + endDateTime;
        CommandAddItem cmd = new CommandAddItem(args);
        cmd.execute(state);
    }
    
    public void addTodo(Todo todo) throws Exception {
        Command cmd = new CommandAddItem(todo);
        cmd.execute(state);
    }
    
    public void addEvent(Event event) throws Exception {
        Command cmd = new CommandAddItem(event);
        cmd.execute(state);
    }
    
    public void addProject(String projectName) {
        Projects projectHandler = state.getProjectHandler();
        projectHandler.createProject(projectName);
    }
    
    public void addToProject(Event event, String projectName) {
        Projects projectHandler = state.getProjectHandler();
        projectHandler.addProjectEvent(event, projectName);
    }
    

}
```
###### ./test/command/CommandUndoTest.java
``` java

package test.command;

import static org.junit.Assert.*;

import org.junit.Test;

import command.CommandUndo;
import helper.CommonHelper;

public class CommandUndoTest {

    String args = null;
    CommandUndo cmd = null;
    
    @Test
    public void testCannotAcceptArguments() {
        try {
            // cannot accept arguments
            args = " item ";
            cmd = new CommandUndo(args);
            fail("exception should be thrown");
        } catch (Exception e) {
            assertEquals(String.format(CommonHelper.ERROR_INVALID_ARGUMENTS, CommandUndo.KEYWORD), e.getMessage());
        }
    }
    
    @Test
    public void testCanAcceptNoArguments() {
        try {
            // delete command accept no arguments
            args = "     ";
            cmd = new CommandUndo(args);
        } catch (Exception e) {
            fail("exception should not be thrown");
        }
    }

}
```
###### ./ui/CLI.java
``` java

package ui;

import java.util.Scanner;

import command.Command;
import command.CommandExit;
import command.Revertible;
import helper.CommonHelper;
import object.State;

public class CLI {
    
    private static Scanner stdin = null;
    private boolean shouldExit;
    
    State currentState;
    
    public CLI() {
        stdin = new Scanner(System.in);
        currentState = new State(true);
        shouldExit = false;
    }
    
    
    private String executeResponse(String userResponse) {
        Command command = null;
        String feedback;
        try {
            command = Command.parseCommand(userResponse);
            feedback = command.execute(currentState);
            if (command instanceof Revertible) {
                // add to history list if project revertible
                currentState.addUndoCommand((Revertible)command);
            }
            
        } catch (Exception e) {
            // catch error message
            feedback = e.getMessage();
        }
        
        if (command instanceof CommandExit) {
            shouldExit = true;
        }
        return feedback;
    }
    
    /**
     * Start command line interface
     */
    public void start() {
        
        System.out.println(CommonHelper.MESSAGE_WELCOME);
        
        while(!shouldExit) {
            System.out.print(CommonHelper.MESSAGE_PROMPT);
            String userResponse = stdin.nextLine();
            String feedback = executeResponse(userResponse);
            System.out.println(feedback);
        }
    }
}
```
###### ./ui/GUI.java
``` java

package ui;

import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;
import object.State;

import java.util.logging.Level;

import command.Command;
import command.CommandUndo;
import command.Revertible;
import helper.MyLogger;

public class GUI extends Application {
    
    private static final String GUI_TITLE          = "NowGotTime";
    private static final String GUI_FONT           = "Lucida Grande";
    public static final String TEXT_FLOATING_TASK  = "Task";
    public static final String TEXT_CHECK          = "\u2714";
    public static final String TEXT_BOX            = "\u2610";
    public static final String TEXT_BULLET         = "\u2022";
    public static final String TEXT_PROJECT        = "Projects";
    public static final String TEXT_TITLE          = "Welcome to NowGotTime!";
    public static final String TEXT_DEFAULT_STATUS = "Hi There!";
    
    private static final int GUI_HEIGHT      = 650;
    private static final int GUI_WIDTH       = 800;
    public static final int FONT_SIZE_HEADER = 24;
    public static final int FONT_SIZE_TITLE  = 22;
    public static final int FONT_SIZE_TEXT   = 20;
    
    private MyLogger logger;
    
    // CSS constant
    private static String CSS_SUCCESS     = "-fx-background-color: #5cb85c; -fx-background-radius: 3;";
    private static String CSS_ERROR       = "-fx-background-color: #d9534f; -fx-background-radius: 3;";
    private static String CSS_WARNING     = "-fx-background-color: #f0ad4e; -fx-background-radius: 3;";
    private static String CSS_DISPLAY_BOX = "-fx-background-color: white; -fx-background-radius: 3;";
    private static String CSS_PROMPT_BOX  = "-fx-font-size: 18px; -fx-font-family: Lucida Grande;";
    private Insets BOX_PADDING = new Insets(10, 10, 10, 10);
    
    GridPane displayBox;
    TextField prompt;
    HBox statusBox;
    Text status;
    Text title;
    
    private State currentState;
    
    private static Font getNormalFont(int size) {
        return Font.font(GUI_FONT, FontWeight.NORMAL, size);
    }
    
    private static Font getBoldFont(int size) {
        return Font.font(GUI_FONT, FontWeight.BOLD, size);
    }
    
    public static Text getText(String string, Color color, int size) {
        Text text = new Text(string);
        text.setFill(color);
        text.setFont(getNormalFont(size));
        text.setTextAlignment(TextAlignment.CENTER);
        return text;
    }
    
    public String executeResponse(String userResponse) {
        Command command = null;
        String feedback;
        
        // Log user response
        logger.log(Level.FINE, userResponse);
        
        try {
            command = Command.parseCommand(userResponse);
            feedback = command.execute(currentState);
            
            // Show on display
            if (!currentState.isTextMode()) {
                prompt.clear();
                statusBox.setStyle(CSS_SUCCESS);
                currentState.updateDisplay(command.getDisplayable());
                currentState.showCurrentDisplay(displayBox);
            }
            
            if (!(command instanceof CommandUndo)) {
                // clear redo stack when non undo command executed
                currentState.clearRedoStack();
            }
            if (command instanceof Revertible) {
                // add to history list if project revertible
                currentState.addUndoCommand((Revertible)command);
            }
            logger.log(Level.FINE, feedback);
            
        } catch (Exception e) {
            // catch error message
            if (!currentState.isTextMode()) {
                statusBox.setStyle(CSS_ERROR);
            }
            feedback = e.getMessage();
            logger.log(Level.WARNING, feedback);
        }
        
        return feedback;
    }
    
    
    
    private HBox getTitleBox() {
        title = new Text(TEXT_TITLE);
        title.setFill(Color.WHITE);
        title.setFont(getNormalFont(FONT_SIZE_TEXT));
        title.setTextAlignment(TextAlignment.CENTER);
        
        HBox titleBox = new HBox(title);
        titleBox.setAlignment(Pos.TOP_CENTER);
        titleBox.setPadding(new Insets(0, 0, 5, 0));
        
        return titleBox;
    }

    private ColumnConstraints getColumn(double percentage) {

        ColumnConstraints column = new ColumnConstraints();
        column.setPercentWidth(percentage);
        
        return column;
    }

    private void displayText(Text field, String text) {
        field.setText(text);
    }
    
    private GridPane getDisplayBox() {
        
        GridPane displayBox = new GridPane();
        displayBox.setVgap(3);
        displayBox.setStyle(CSS_DISPLAY_BOX);
        displayBox.setPadding(BOX_PADDING);
        displayBox.setMinHeight(GUI_HEIGHT-142);

        displayBox.getColumnConstraints().add(getColumn(7.0));
        displayBox.getColumnConstraints().add(getColumn(5.0));
        displayBox.getColumnConstraints().add(getColumn(50.0));
        displayBox.getColumnConstraints().add(getColumn(38.0));
        displayBox.getColumnConstraints().add(getColumn(1.0));
        
        return displayBox;
    }
    
    private HBox getPromptBox() {
        prompt = new TextField();
        prompt.setStyle(CSS_PROMPT_BOX);

        HBox promptBox = new HBox(prompt);
        HBox.setHgrow(prompt, Priority.ALWAYS);
        promptBox.setAlignment(Pos.BOTTOM_CENTER);
        promptBox.setPadding(new Insets(5, 0, 5, 0));
        
        return promptBox;
    }
    
    private HBox getStatusBox() {
        status = new Text(TEXT_DEFAULT_STATUS);
        status.setFont(getBoldFont(20));
        status.setFill(Color.WHITE);
        status.setTextAlignment(TextAlignment.CENTER);
        
        HBox statusBox = new HBox(status);
        statusBox.setAlignment(Pos.BOTTOM_CENTER);
        statusBox.setPadding(new Insets(5, 0, 5, 0));
        statusBox.setStyle(CSS_WARNING);
        
        return statusBox;
    }
    
    private void addEnterHandler(Node node) {
        node.setOnKeyPressed(new EventHandler<KeyEvent>()
        {
            @Override
            public void handle(KeyEvent event) {
                if (event.getCode().equals(KeyCode.ENTER)) {
                    displayText(status, executeResponse(prompt.getText()));
                }
            }
        });
    }
    
    private void addMaxLengthHandler(TextField tf, int maxLength) {
        tf.textProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(final ObservableValue<? extends String> ov, final String oldValue, final String newValue) {
                if (tf.getText().length() > maxLength) {
                    String s = tf.getText().substring(0, maxLength);
                    tf.setText(s);
                }
            }
        });
    }
    
    private Scene getUserInterface() {
        
        // setup ui
        StackPane ui = new StackPane();
        ui.setPadding(BOX_PADDING);
        ui.setStyle("-fx-background-color: #333333;");

        // create ui component
        HBox titleBox = getTitleBox();
        HBox promptBox = getPromptBox();
        
        displayBox = getDisplayBox();
        statusBox = getStatusBox();

        // add enter key handler;
        addEnterHandler(prompt);
        addMaxLengthHandler(prompt, 80);
        
        // setup input output box
        VBox ioBox = new VBox();
        ioBox.setAlignment(Pos.BOTTOM_CENTER);
        
        // setup display box
        VBox upperBox = new VBox();
        upperBox.setPadding(new Insets(0, 0, 5, 0));
        
        // make a scroll pane for display box
        ScrollPane scrollBox = new ScrollPane();
        scrollBox.setContent(displayBox);
        scrollBox.fitToHeightProperty();
        scrollBox.setPrefSize(200, GUI_HEIGHT-140);
        scrollBox.setHbarPolicy(ScrollBarPolicy.NEVER);
        scrollBox.setFitToWidth(true);
        scrollBox.setStyle("-fx-background-radius: 4;");
        
        // attach everything
        ioBox.getChildren().addAll(statusBox, promptBox);
        upperBox.getChildren().addAll(titleBox, scrollBox);
        ui.getChildren().addAll(upperBox, ioBox);
        ioBox.setMouseTransparent(true);
        
        return new Scene(ui, GUI_WIDTH, GUI_HEIGHT);
    }
    
    public void initiateState(boolean textMode) {
        logger = new MyLogger();
        currentState = new State(textMode);
    }
    
    public void initiateState() {
        initiateState(false);
    }
    
	@Override
	public void start(Stage primaryStage) throws Exception {
	    initiateState();
	    
	    primaryStage.setTitle(GUI_TITLE);
	    
	    Scene ui = getUserInterface();
	    
	    // Show current display to displaybox
	    currentState.showCurrentDisplay(displayBox);
	    
	    primaryStage.setScene(ui);
	    primaryStage.setResizable(false);
	    primaryStage.show();
	}


    public static void main(String[] args) {
		launch(args);
	}
}
```
###### ./ui/Main.java
``` java

package ui;

public class Main {

    public static void main(String[] args) {
        
        if (args.length == 0) {
            CLI ui = new CLI();
            ui.start();
        } else {
            GUI.main(args);
        }
    }

}
```
