# A0124402Y
###### ./src/helper/MyLogger.java
``` java
package helper;

import java.io.File;
import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class MyLogger {
	
	private static final String DEFAULT_PATH = System.getProperty("user.dir").toString() + "/LogFiles/";
	private static final String DEFAULT_LOG_FILE = DEFAULT_PATH + "MyLogging.log";
	private static Logger logger = Logger.getLogger("My Log");
	private static FileHandler fh;
	
	public MyLogger(){
		File file = new File(DEFAULT_PATH);
		if(file.exists()){
			return;
		}else{
			file.mkdir();
		}
		
		try{
			
			fh = new FileHandler(DEFAULT_LOG_FILE);
			logger.addHandler(fh);
			SimpleFormatter formatter = new SimpleFormatter();  
	        fh.setFormatter(formatter);  
	        
		}catch(IOException e){
			logger.log(Level.SEVERE, "Can't log");
		}
	}
		
	public void log(Level level, String msg){
	    logger.log(level, msg); 
	}
	
	public void logp(Level level, String sourceClass, String sourceMethod, String msg){
		logger.logp(level, sourceClass, sourceMethod, msg);
	}
	
	public void entering(String sourceClass, String sourceMethod){
		logger.entering(sourceClass, sourceMethod);
	}
	
	public void exiting(String sourceClass, String sourceMethod){
		logger.exiting(sourceClass, sourceMethod);
	}
	
}
```
###### ./src/storage/DirectoryHandler.java
``` java
package storage;
import helper.MyLogger;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;

/**
 * 
 * @author RX.huang
 * 
 * This class is in-charge of creating, checking and changing of directories.
 * 
 */
public class DirectoryHandler {
	
	private static final String DATABASE = "database";

	private MyLogger myLogger = new MyLogger();
	
	private static final String PROJECT = "Project";
	private static final String EVENT = "Event";
	private static final String TODO = "Todo";
	private static final String END_OF_PATH_DIRECTORY = "<endOfPathDirectory>";
	private static final String OVERVIEW = "overview.txt";
	
	private String todoPath;
	private String eventPath;
	private String projectPath;
	private String baseDirectory;

	
/********************* Public class methods **********************************/
	
	public DirectoryHandler(){
		if(!doesFileExist(OVERVIEW)){
			setUpDirectory(null);
		} else{
			checkDirectories();
		}
	}
	
	/**
	 * Retrieve the address of the base directory.
	 * @return
	 */
	public String getBaseDirectory(){
		return baseDirectory;
	}
	
	/**
	 * Set a new directory to where the data will be saved.
	 * @param theBaseDirectory
	 * @return
	 */
	public boolean setNewBaseDirectory(String theBaseDirectory){
		if(theBaseDirectory != null && (new File(theBaseDirectory).exists())){
			String oldDirectory = baseDirectory;			
			if(setUpDirectory(theBaseDirectory)){
				return true;
			} else{
				setUpDirectory(oldDirectory);	//revert back
			}
		}
		return false;
	}
	
/************************* Private class methods *****************************/
	
	/**
	 * return true if directories have all been created, return false if some/all directories failed to be created.
	 * @param theBaseDirectory
	 * @return
	 */
	private boolean setUpDirectory(String theBaseDirectory){
		if(theBaseDirectory != null){
			baseDirectory = theBaseDirectory;
			baseDirectory = createDirectory(DATABASE);
			
			if(baseDirectory == null){
				return false;
			}
		}

		todoPath = createDirectory(TODO);
		eventPath = createDirectory(EVENT);
		projectPath = createDirectory(PROJECT);
		
		if(todoPath != null && eventPath != null && projectPath != null){
			return writeOverviewTextFile();
		}
		return false;
	}
	
	/**
	 * create directory if they are missing.
	 * @return
	 */
	private boolean checkDirectories() {	
		readOverviewFile();
		
		if( !doesFileExist(todoPath) ){
			createDirectory(TODO);
		}
		
		if( !doesFileExist(eventPath) ){
			createDirectory(EVENT);
		}
		
		if( !doesFileExist(projectPath) ){
			createDirectory(PROJECT);
		}
		
		return true;
	}

	private boolean doesFileExist(String path){
		return new File(path).exists();
	}
	
	/**
	 * return String of directory path if created, else return null
	 * @param directoryName
	 * @return
	 */
	private String createDirectory(String directoryName){
		//this is to differentiate setting up default dir, or changing to new dir
		if(baseDirectory == null){
			baseDirectory = getDefaultDirectory();
			if(baseDirectory == null){
				return null;
			}
		}
		
		String newDirectoryPath = baseDirectory.concat("/" + directoryName);
		if(makeNewDirectory(newDirectoryPath)){
			return newDirectoryPath;
		} else{
			return null;
		}
	}
	
	private boolean writeOverviewTextFile(){
		try{
			File outfile = new File(OVERVIEW);
			BufferedWriter writer = new BufferedWriter(new FileWriter(outfile));
			
			writer.write(baseDirectory); 
			writer.newLine();
			writer.write(todoPath); 
			writer.newLine();
			writer.write(eventPath); 
			writer.newLine();
			writer.write(projectPath); 
			writer.newLine();
			writer.write(END_OF_PATH_DIRECTORY);
			writer.close();
			return true;
	
		} catch(IOException e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"writeOverviewTextFile", e.getMessage());
			return false;
		}
	}
	
	private String getDefaultDirectory(){
		String baseDirectory = System.getProperty("user.dir").toString() + "/" + DATABASE;
		File file = new File(baseDirectory);
		if(!file.exists()){
			if(!file.mkdir()){
				myLogger.logp(Level.SEVERE, getClass().getName(), 
						"readOverviewFile", "creation of default directory failed.");
				return null;
			}			
		}
		
		return baseDirectory;
	}
	
	private boolean makeNewDirectory(String directoryName){
		File file = new File(directoryName);
		if (!file.exists()) {
			return file.mkdir();
		}
		return false;
	}
	 
	private boolean readOverviewFile(){
		File outfile = new File(OVERVIEW);
		try {
			BufferedReader reader = new BufferedReader(new FileReader(outfile));
			
			baseDirectory = reader.readLine();
			todoPath = reader.readLine();
			eventPath = reader.readLine();
			projectPath = reader.readLine();
			
			reader.close();
			return true;
			
		} catch (Exception e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readOverviewFile", e.getMessage());
			return false;
		}		
	}
}
```
###### ./src/storage/FileEventHandler.java
``` java
package storage;

import helper.CalendarHelper;
import helper.MyLogger;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.logging.Level;

import object.Event;
import object.Item;

/**
 * 
 * @author RX.huang
 * 
 * This class is responsible for data storage and retrieval of 
 * Event objects.
 * 
 */
public class FileEventHandler {
	
	private MyLogger myLogger = new MyLogger();
	
	private static final String EVENTS = "All_Events.txt";
	private static final String EVENT = "Event";
	private String baseDirectory;
	
	private ArrayList<Event> allEvents = new ArrayList<Event>();
	private ArrayList<Event> allEventsClone= new ArrayList<Event>();
	
/*****************************************************************************************/		

 	@SuppressWarnings("unchecked")
	public FileEventHandler(String theBaseDirectory){
		this.baseDirectory = theBaseDirectory.concat("/");
		allEvents = retrieveEvent();
		allEventsClone = (ArrayList<Event>) allEvents.clone();
	}

	public boolean saveNewEventHandler(Event event){
		allEventsClone.add(event);
		return saveEventBook();
	}
			
	@SuppressWarnings("unchecked")
	public boolean saveEventBook(){
		// ensure the the allEvents is updated to AllEventsClone
		if(allEvents != allEventsClone){
			allEvents = allEventsClone;
		}
		
		sortEventsByDate(allEvents);
		
		// ensure that allEventsClone and allEvents do not have the same reference.
		allEventsClone = (ArrayList<Event>) allEvents.clone();
		return writeToFile();
	}
	
	public boolean setNewDirectory(String newBaseDirectory){
		if((newBaseDirectory != null) && new File(newBaseDirectory).exists()){
			baseDirectory = newBaseDirectory.concat("/" + EVENT + "/");
			return true;
		}
		return false;
	}
	
	public ArrayList<Event> retrieveEventByDate(String dateString){
		ArrayList<Event> eventBookByDate = new ArrayList<Event>();
		Calendar date = Calendar.getInstance();
		if( (date = createDate(dateString, date)) == null){
			return null;
		}
		
		extractEventByDate(eventBookByDate, date);
		return eventBookByDate;
	}

	@SuppressWarnings("unchecked")
	public ArrayList<Event> retrieveAllEvents(){
		allEvents = retrieveEvent();
		allEventsClone = (ArrayList<Event>) allEvents.clone();
		return allEventsClone;
	}
	
/*************************************************************************************/
 	
	private Calendar createDate(String dateString, Calendar date) {
		try {
			date = CalendarHelper.parseDate(dateString);
			setZeroTime(date);
		} catch (ParseException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"createDate", e.getMessage());
			return null;
		}
		return date;
	}
	
	private Event createEvent(String eventName, String startDate, String endDate,
			String startTime, String endTime, String addInfo, String ID,
			boolean isDone) {
		Event event = new Event(eventName, startDate, endDate, startTime, endTime, addInfo);
		event.setId(Integer.parseInt(ID));
		event.setDone(isDone);
		return event;
	}
	
	private void extractEventByDate(ArrayList<Event> eventBookByDate, Calendar date) {
		ArrayList<Event> eventBook = allEvents;
		Calendar startDate, endDate;
		
		for(Event event: eventBook){
			startDate = (Calendar) event.getStartCalendar().clone();
			endDate = (Calendar) event.getEndCalendar().clone();
			setZeroTime(startDate);
			setZeroTime(endDate);
			
			if( date.equals(startDate) || date.equals(endDate) || 
					(date.after(startDate) && date.before(endDate) ) ){
				eventBookByDate.add(event);
			}
		}
	}
	
	private ArrayList<Event> retrieveEvent(){
		ArrayList<Event> eventBook = new ArrayList<Event>();
		String eventName, startDate, endDate, startTime, endTime, addInfo, ID;
		boolean isDone;
		int counter = Item.getCounter();
		
		try {
			File inputFile = new File(baseDirectory + EVENTS);
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			String lineOfText;
			
			while( (lineOfText = reader.readLine()) != null ){
				ID = lineOfText;
				eventName = reader.readLine();
				startDate = reader.readLine();
				endDate = reader.readLine();
				startTime = reader.readLine();
				endTime = reader.readLine();
				isDone = Boolean.parseBoolean(reader.readLine());
				addInfo = "";
				
				Event event = createEvent(eventName, startDate, endDate,
						startTime, endTime, addInfo, ID, isDone);
				eventBook.add(event);
			}
			reader.close();
			
			//prevent counter from incrementing
			Item.setCounter(counter);
			return eventBook;
			
		} catch (FileNotFoundException e) {
			myLogger.logp(Level.WARNING, getClass().getName(),
					"retrieveEvent", e.getMessage());
			saveEventBook();
			return eventBook;
			
		} catch (IOException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"retrieveEvent", e.getMessage());
			return eventBook;
			
		}
	}
	
	private void setZeroTime(Calendar date){
		date.set(Calendar.HOUR_OF_DAY, 0);
		date.set(Calendar.MINUTE, 0);
		date.set(Calendar.SECOND, 0);
		date.set(Calendar.MILLISECOND, 0);
	}
	
	private boolean sortEventsByDate(ArrayList<Event> eventBook){
		if(eventBook != null){
			Collections.sort(eventBook);
			return true;
		}
		return false;
	}
	
	private boolean writeToFile(){
		
		assert(allEvents != null);
		
		try{
			File outfile = new File(baseDirectory + EVENTS);
			BufferedWriter writer = new BufferedWriter(new FileWriter(outfile));	
			
			for(Event anEvent : allEvents){
				writer.write(anEvent.toString()); 
				writer.newLine();
				writer.write(anEvent.getDone() + "");
				writer.newLine();
			}
			
			writer.close();
			return true;
	
		}catch(Exception e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"writeToFile", e.getMessage());
			return false;
		}
	}
}
```
###### ./src/storage/FileHandler.java
``` java
package storage;

import helper.MyLogger;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;

import object.Event;
import object.Item;
import object.Todo;

/**
 * 
 * @author RX.huang
 *
 * This is the main and only class that the logic components will interact with 
 * for data storage and retrieval operations.
 * 
 */
public class FileHandler implements FileManager{
	
	private MyLogger myLogger = new MyLogger();
	
	private static final String FLOATING_TODO = "Floating_Todo.txt";
	private static final String NORMAL_TODO = "Normal_Todo.txt";
	
	private static final String EVENT_OVERVIEWER = "overview.txt";
	private static final String COUNTER = "Counter.txt";
		
	private File inputFile;
	private String eventPath;
	private String todoPath;
	private String projectPath;
	
	private FileProjectHandler fProjH;
	private FileEventHandler fEventH;
	private FileTodoHandler fTodoH;
	
	private DirectoryHandler directHand;
	
/******************************* Constructor *************************************/	
	
	/**
	 * Creates a new instance of the FileHandler.
	 */
	public FileHandler(){
		directHand = new DirectoryHandler();
		readOverviewerFile();
		fEventH = new FileEventHandler(eventPath);
		fProjH = new FileProjectHandler(projectPath);
		fTodoH = new FileTodoHandler(todoPath);
		
		readCounter();
				
	}
	
/********************************* Events ****************************************/
	
	/**
	 * Retrieves a specific events by date
	 */
	@Override
	public ArrayList<Event> retrieveEventByDate(String date){
		if(date != null){
			return fEventH.retrieveEventByDate(date);
		}else{
			return null;
		}
	}
	
	/**
	 * Retrieves an ArrayList of events to make changes/delete
	 */
	public ArrayList<Event> retrieveAllEvents(){
		return fEventH.retrieveAllEvents();
	}
	
	/**
	 * Saves a new Event
	 */
	@Override
	public boolean saveNewEventHandler(Event event){
		if(event != null){
			writeCounter();
			return fEventH.saveNewEventHandler(event);
			
		}else{
			return false;
		}
	}
	
	/**
	 * Saves any changes made to the ArrayList<Event> retrieved 
	 * using the retrieveAllEvent() method
	 */
	@Override
	public boolean saveEditedEventHandler() {
		writeCounter();
		return fEventH.saveEventBook();
	}

/********************************* Todo *****************************************/
	
	/**
	 * Retrieves a specific task by date
	 */
	@Override
	public ArrayList<Todo> retrieveTodoByDate(String date) {
		if(date != null)
			return fTodoH.retrieveTodoByDate(date);
		else
			return null;
	}
	
	/**
	 * Retrieves an ArrayList of tasks to make changes/delete
	 */
	public ArrayList<Todo> retrieveAllTodo(){
		return fTodoH.retrieveAllTodo();
	}
	
	/**
	 * Retrieves all the floating Tasks available
	 */
	@Override
	public ArrayList<Todo> retrieveUniversalTodo() {
		return fTodoH.retrieveFloatingTodo();
	}
	
	/**
	 * Saves a new task
	 */
	@Override
	public boolean saveNewTodoHandler(Todo task) {
		if(task != null){
			writeCounter();
		return fTodoH.saveNewTodoHandler(task);
		}else{
			return false;
		}
	}
	
	/**
	 * Saves any changes made to the ArrayList<Todo> retrieved using the 
	 * retrieveAllTodo() method
	 */
	@Override
	public boolean saveEditedTodoHandler() {
		writeCounter();
		fTodoH.separateTodoTypes();
		return fTodoH.saveChange(NORMAL_TODO);
	}
		
	/**
	 * Saves all the Todo and Floating Todo into text files
	 */
	@Override
	public boolean saveAllEditedTodo(){
		writeCounter();
		fTodoH.separateTodoTypes();
		return fTodoH.saveChange(NORMAL_TODO) && fTodoH.saveChange(FLOATING_TODO);
	}
	
/******************************** Project **************************************/
	
	/**
	 * Retrieves all the events added to a project
	 */
	@Override
	public ArrayList<Integer> retrieveProjectTimeLine(String projectName) {
		if(projectName != null){
			return fProjH.retrieveProject(projectName);
		} else {
			return null;
		}
	}
	
	@Override
	public HashMap<Integer, String> retrieveProjectProgress() {
		return fProjH.retrieveProjectProgress();
	}
	
	/**
	 * Creates a new text file to store information of a new project
	 */
	@Override
	public boolean createNewProject(String projectName) {
		return fProjH.createNewProject(projectName);
	}
	
	/**
	 * Saves any changes made to the ArrayList<Integer> retrieved using the retrieveProjectTimeLine( ) method
	 */
	@Override
	public boolean saveEditedProjectDetails(ArrayList<Integer> projectBook, HashMap<Integer, String> progressBook, String projectName) {
		if(projectBook == null || progressBook == null || projectName == null){
			return false;
		} else{
			projectName = projectName.toLowerCase();
			return fProjH.saveEditedProjectDetails(projectBook, progressBook, projectName);
		}
	}

	/**
	 * Retrieves the names of all the existing project 
	 */
	@Override
	public ArrayList<String> getListOfExistingProject() {
		return fProjH.getListOfExistingProjects();
	}
	
	/**
	 * Deletes the entire project 
	 */
	@Override
	public boolean deleteProject(String projectName){
		if(projectName != null){
			return fProjH.deleteProject(projectName);
		} else{
			return false;
		}	
	}
	
/****************************** Internal *************************************/	
	
	private void readOverviewerFile() {
		inputFile = new File(EVENT_OVERVIEWER);	
		
		try {
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			
			reader.readLine();
			todoPath = reader.readLine();
			eventPath = reader.readLine();
			projectPath = reader.readLine();
			
			reader.close();		 
		}
		catch (Exception e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readOverViewerFile", e.getMessage());
		}
	}
	
	private void readCounter(){
//		System.out.println("Counter is " + Item.getCounter()); //for checking
		Item.setCounter(0);
		inputFile = new File(COUNTER);	
		
		try {
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			
			int counter = Integer.parseInt(reader.readLine());
//			System.out.println("Counter is now set to " + counter); //for checking
			Item.setCounter(counter);
			
			reader.close();		 
		}
		catch (FileNotFoundException e) {
			writeCounter();
		}catch (IOException e) {
			// Do nothing
		}
	}
	
	private boolean writeCounter(){
		
//		System.out.println("Counter is now " + Item.getCounter()); //for checking
		
		try{
			File outfile = new File(COUNTER);
			
			BufferedWriter writer = new BufferedWriter(new FileWriter(outfile));	
			
			int counter = Item.getCounter();
			writer.write(counter + ""); 
			
			writer.close();
			return true;
	
		}catch(IOException e){
			System.out.println("File cannot be written.\n");
			return false;
		}
	}
	
/****************************** Directory *************************************/
	/**
	 * Takes in a new directory for storage data to be stored and 
	 * transfers all the existing files to the new directory.
	 * @param newBaseDirectory
	 * @return
	 */
	@Override
	public boolean changeBaseDirectory(String newBaseDirectory){
		if(newBaseDirectory != null && (new File(newBaseDirectory).exists())){
			fProjH.readAll();
			clearAll();
			if(directHand.setNewBaseDirectory(newBaseDirectory)){
				newBaseDirectory = newBaseDirectory + "/database";
				fEventH.setNewDirectory(newBaseDirectory);
				fTodoH.setNewDirectory(newBaseDirectory);
				fProjH.setNewDirectory(newBaseDirectory);
			}
			saveAll();
			return true;
		}
		return false;		
	}
	
	/**
	 * Saves all the data available to the text files.
	 * @return
	 */
	public boolean saveAll(){
		return fEventH.saveEventBook() &&
				fTodoH.saveChange(NORMAL_TODO) &&
				fTodoH.saveChange(FLOATING_TODO) &&
				fProjH.writeAll() && writeCounter();
	}
	
	/**
	 * Deletes all text files available
	 */
	public void clearAll(){
		String baseDirectory = directHand.getBaseDirectory();
		cleanUp(baseDirectory);
		cleanUp(EVENT_OVERVIEWER);
		cleanUp(COUNTER);
	}
	
	/**
	 * Clean up directory, mainly for the purpose of the changing of directory
	 * @param baseDirectory
	 * @return
	 */
	public boolean cleanUp(String baseDirectory){
		try {
			File dir = new File(baseDirectory);
			if(dir.isDirectory() && dir.list().length > 0){
				for(File file: dir.listFiles()) {
					if(!file.isDirectory()){
						file.delete(); 
					}else{
						cleanUp(file.getPath());
					}
				}
			} else{
				dir.delete();
			}
			
			Path path = Paths.get(baseDirectory);
			Files.delete(path);
			return true;
		} catch(Exception e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"cleanUp", e.getMessage());
		}
		return false;
	}

/****************************** Item *****************************************/
	/**
	 * Retrieves event by the ID assigned. 
	 * @param wantedId
	 * @return
	 */
	@Override
	public Event retrieveEventById(int wantedId){
		ArrayList<Event> allEvent = fEventH.retrieveAllEvents();
		for(Event event: allEvent){
			if(event.getId() == wantedId){
				return event;
			}
		}
		return null;
	}
	
	/**
	 * Retrieves task by the ID assigned
	 * @param wantedId
	 * @return
	 */
	@Override
	public Todo retrieveTaskById(int wantedId){
		ArrayList<Todo> allTodo = fTodoH.retrieveAllTodo();
		for(Todo todo: allTodo){
			if(todo.getId() == wantedId){
				return todo;
			}
		}
		return null;
	}
	
}
```
###### ./src/storage/FileManager.java
``` java
package storage;

import java.util.ArrayList;
import java.util.HashMap;

import object.Event;
import object.Todo;

/**
 * 
 * @author RX.huang
 * 
 * This is an interface implemented by FileHandler. The interface ensures that
 * FileHandler contains fixed methods that can be used by the Logic component.
 * 
 */
public interface FileManager {

	public ArrayList<Event> retrieveEventByDate(String date); 
	public ArrayList<Event> retrieveAllEvents();
	public boolean saveNewEventHandler(Event event);
	public boolean saveEditedEventHandler();
	
	public ArrayList<Todo> retrieveTodoByDate(String date);
	public ArrayList<Todo> retrieveAllTodo();
	public ArrayList<Todo> retrieveUniversalTodo();
	public boolean saveNewTodoHandler(Todo task);
	public boolean saveEditedTodoHandler();
	public boolean saveAllEditedTodo();
	
	public ArrayList<Integer> retrieveProjectTimeLine(String projectName);
	public HashMap<Integer, String> retrieveProjectProgress();
	public boolean createNewProject(String projectName);
	public boolean saveEditedProjectDetails(ArrayList<Integer> projectBook, HashMap<Integer, String> progressBook, String projectName);
	public ArrayList<String> getListOfExistingProject( );
	public boolean deleteProject(String projectName);
	
	public boolean changeBaseDirectory(String newBaseDirectory);

	public Event retrieveEventById(int wantedId);
	public Todo retrieveTaskById(int wantedId);
	
}
```
###### ./src/storage/FileProjectHandler.java
``` java

package storage;

import helper.MyLogger;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;

/**
 * 
 * @author RX.huang
 *
 * This class is responsible for data storage and retrieval of project related 
 * information.
 *
 */
public class FileProjectHandler {
	
	private MyLogger myLogger = new MyLogger();
	
	private static final String PROJECT_OVERVIEWER = "projectOverviewer.txt";
	private static final String PROJECT = "Project";
	
	private String baseDirectory;
	private File inputFile;
	
	private ArrayList<String> existingProjects;
	private HashMap<Integer, String> progressBook;
	private ArrayList<ArrayList<Integer>> projectBookShelf;
	private ArrayList<HashMap<Integer, String>> progressBookShelf;
	
/*******************************************************************************/
	
	/**
	 * Construct an instance of project handler with all the project details.
	 * @param baseDirectory
	 */
	public FileProjectHandler(String baseDirectory){
		this.baseDirectory = baseDirectory.concat("/");
		
		projectBookShelf = new ArrayList<ArrayList<Integer>>();
		progressBookShelf = new ArrayList<HashMap<Integer, String>>();
		progressBook = new HashMap<Integer, String>();
		
		readOverviewerFile();
	}
	
	/**
	 * Delete the whole project with the projectName.
	 * @param projectName
	 * @return true if project has been successfully deleted, else return false
	 */
	public boolean deleteProject(String projectName){		
		if(!existingProjects.contains(projectName) || projectName == null){
			return false;
		}
		
		projectName = projectName.toLowerCase();
		
		existingProjects.remove(projectName);
		updateOverviewFile();
		
		Path path = Paths.get(baseDirectory + projectName + ".txt");
		
		try {
		    Files.delete(path);
		    return true;
		    
		} catch (NoSuchFileException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"deleteProject", e.getMessage());
		    return false;
		    
		} catch (DirectoryNotEmptyException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"deleteProject",  e.getMessage());
		    return false;
		    
		} catch (IOException e) {
		    // File permission problems are caught here.
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"deleteProject", e.getMessage());
		    return false;
		}
	}
	
	/**
	 * Retrieve the names of the existing projects
	 * @return ArrayList<String> containing the names of existing projects, 
	 * return empty ArrayList<String> if there are no existing projects.
	 */
	@SuppressWarnings("unchecked")
	public ArrayList<String> getListOfExistingProjects(){
		return (ArrayList<String>) existingProjects.clone();
	}
	
	/**
	 * Retrieve the index of events added into a project
	 * @param name of the project to be retrieved
	 * @return ArrayList<Integer> of index, return empty ArrayList<Integer> if 
	 * there are no events in the project
	 */
	public ArrayList<Integer> retrieveProject(String name){
	
		name = name.toLowerCase();
		ArrayList<Integer> projectBook = new ArrayList<Integer>();
		progressBook = new HashMap<Integer, String>();
		String fileName = name + ".txt";
		String addInfo;
		int id;
		
		try{
			File inputFile = new File(baseDirectory + fileName);
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			String lineOfText;
			
			while( (lineOfText = reader.readLine()) != null){
				id = Integer.parseInt(lineOfText);
				addInfo = reader.readLine();
				
				projectBook.add(id);
				progressBook.put(id, addInfo);
			}
			reader.close();
			return projectBook;
			
		}catch(Exception e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"retrieveProject", e.getMessage());
			return projectBook;
		}		 
	}
	
	/**
	 * Retrieve the Progress statements of the events in the project.
	 * @return a HashMap, where the key is the ID for the event, 
	 * and the value is the String of the progress details
	 */
	public HashMap<Integer, String> retrieveProjectProgress(){
		assert(progressBook != null);
		return progressBook;
	}
	
	/**
	 * Create a new project.
	 * @param projectName
	 * @return true if the project has been created, else return false. 
	 */
	public boolean createNewProject(String projectName){
		if(!existingProjects.contains(projectName) && projectName != null 
				&& !projectName.isEmpty()){
			projectName = projectName.toLowerCase();
			return createNewProjectFile(projectName);
		}
		return false;
	}
	
	/**
	 * Save any changes done to the project
	 * @param projectBook contains the index of events in the project
	 * @param progressBook contains the progress statements of events in the project
	 * @param projectName 
	 * @return true if the project has been successfully saved, else return false.
	 */
	public boolean saveEditedProjectDetails(ArrayList<Integer> projectBook, 
					HashMap<Integer, String> progressBook, String projectName){
					
		try{
			File outfile = new File(baseDirectory + projectName + ".txt");
			
			if(!outfile.exists()){
				return false; 
			}
			
			BufferedWriter writer = new BufferedWriter(new FileWriter(outfile));	
			
			for(Integer id : projectBook){
				writer.write(id.toString()); writer.newLine();
				if(progressBook.isEmpty()){
					writer.write("");
				}else{
					if(progressBook.get(id) == null){
						writer.write("");
					}else{
						writer.write(progressBook.get(id));
					}
				}
				writer.newLine();
			}
			writer.close();
			return true;
	
		}catch(Exception e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"saveEditedProjectDetails", e.getMessage());
			return false;
		}	
	}
	
	/**
	 * Set another new base directory
	 * @param newBaseDirectory
	 * @return true if directory has been updated, else return false
	 */
	public boolean setNewDirectory(String newBaseDirectory){	
		if((newBaseDirectory != null) && new File(newBaseDirectory).exists()){
			baseDirectory = newBaseDirectory.concat("/" + PROJECT + "/");
			return true;
		}
		return false;	
	}
	
	/**
	 * read in all the existing projects
	 * @return true if successful in reading the projects, else return false.
	 */
	public boolean readAll(){
		projectBookShelf = new ArrayList<ArrayList<Integer>>();
		progressBookShelf = new ArrayList<HashMap<Integer, String>>();
		
		for(String project: existingProjects){
			ArrayList<Integer> projectBook = retrieveProject(project);
			HashMap<Integer, String> progressBook = retrieveProjectProgress();
			projectBookShelf.add(projectBook);
			progressBookShelf.add(progressBook);
		}
		
		return true;
	}
	
	/**
	 * Save all the project data onto text files.
	 * @return true when successfully written all the existing projects, else return false
	 */
	public boolean writeAll(){
		updateOverviewFile();
		
		try {
			for(int counter = 0; counter < existingProjects.size(); counter++){
				
				String projectName = existingProjects.get(counter);
				ArrayList<Integer> projectBook = projectBookShelf.get(counter);
				HashMap<Integer, String> progressBook = progressBookShelf.get(counter);
				createNewProjectFile(projectName);
				saveEditedProjectDetails(projectBook, progressBook, projectName);
			}
			
			return true;
			
		} catch (NullPointerException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"writeAll", e.getMessage());
			return false;
		}
	}
	
/*******************************************************************************/
	/**
	 * create a new project
	 * @param textFileName
	 * @return true when successful in creating the project file, else return false.
	 */
	private boolean createNewProjectFile(String textFileName){
		try{
			File newFile = new File(baseDirectory + textFileName + ".txt");
				
			if(!existingProjects.contains(textFileName)){
				existingProjects.add(textFileName);
				updateOverviewFile();
			}
			
			return newFile.createNewFile();
			
		}catch(Exception e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"createNewProjectFile", e.getMessage());
			existingProjects.remove(textFileName);
			updateOverviewFile();
			return false;
		}
	}
	
	/**
	 * read the overview file which contains the list of names of all the
	 * existing projects
	 */
	private void readOverviewerFile() {
		inputFile = new File( baseDirectory + PROJECT_OVERVIEWER);	
		existingProjects = new ArrayList<String>();
		
		try {
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			String projectName;
			
			while((projectName = reader.readLine()) != (null)){
				existingProjects.add(projectName);
			}		
			reader.close();		 
		}
		catch (FileNotFoundException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readOverviewerFile", e.getMessage());
			updateOverviewFile();
		}catch (Exception e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readOverviewerFile", e.getMessage());
		}
	}
	
	/**
	 * Save any changes in project files.
	 * @return
	 */
	private boolean updateOverviewFile(){
		try{
			File outfile = new File(baseDirectory + PROJECT_OVERVIEWER);

			BufferedWriter writer = new BufferedWriter(new FileWriter(outfile));	
			
			for(String projectName : existingProjects){
				writer.write(projectName); 
				writer.newLine();
			}
			writer.close();
			return true;
	
		}catch(Exception e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"updateOverviewFile", e.getMessage());
			return false;
		}
	}
}
```
###### ./src/storage/FileTodoHandler.java
``` java
package storage;

import helper.CalendarHelper;
import helper.MyLogger;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.logging.Level;

import object.Todo;

/**
 * 
 * @author RX.huang
 *
 * This class is responsible for data storage and retrieval of Todo objects.
 *
 */
public class FileTodoHandler {
	
	private MyLogger myLogger = new MyLogger();
	
	private static final String BASIC_TODO_TYPE = "basic";
	private static final String PARTIAL_TODO_TYPE = "partial";
	private static final String COMPLETE_TODO_TYPE = "complete";
	
	private static final String FLOATING_TODO = "Floating_Todo.txt";
	private static final String NORMAL_TODO = "Normal_Todo.txt";
	private static final String TODO = "Todo";
	
	private String baseDirectory;
	
	private ArrayList<Todo> allTodo = new ArrayList<Todo>();
	private ArrayList<Todo> allTodoClone = new ArrayList<Todo>();
	private ArrayList<Todo> universalTodo = new ArrayList<Todo>();
	
/********************************** Public method for users *****************************************/		
	
	public FileTodoHandler(String baseDirectory){
		this.baseDirectory = baseDirectory.concat("/");
		retrievePassedTasks();
	}
	
	public ArrayList<Todo> retrieveTodoByDate(String dateString){
		
		assert(dateString != null); 	//checked by FileHandler first
		
		ArrayList<Todo> toDoListByDate = new ArrayList<Todo>();
		Calendar date = Calendar.getInstance();
		
		if( (date = createDate(dateString, date)) == null){
			return null;
		}
		
		extractTodoByDate(toDoListByDate, date);
		return toDoListByDate;	
	}
	
	public ArrayList<Todo> retrieveFloatingTodo(){
		return universalTodo;
	}
	
	@SuppressWarnings("unchecked")
	public ArrayList<Todo> retrieveAllTodo(){
		ArrayList<Todo> tempTodo = (ArrayList<Todo>) allTodo.clone();
		ArrayList<Todo> tempUniversalTodo = (ArrayList<Todo>) universalTodo.clone();
		
		allTodoClone.clear();
		allTodoClone.addAll(tempTodo);
		allTodoClone.addAll(tempUniversalTodo);
		return allTodoClone;
	}
	
	public boolean saveNewTodoHandler(Todo todo){
		
		if(todo.hasDate()){
			allTodo.add(todo);
			return saveChange(NORMAL_TODO);
			
		} else{
			universalTodo.add(todo);
			return saveChange(FLOATING_TODO);
		}	
	}
			
	public boolean saveChange(String type){
		
		assert(type == NORMAL_TODO || type == FLOATING_TODO);
		
		ArrayList<Todo> tempTodo;
		
		if(type.equals(NORMAL_TODO)){
			tempTodo = allTodo;
		}else{
			tempTodo = universalTodo;
		}
		
		sortTodoByDate(tempTodo);
		return writeToFile(type);	
	}
	
	public boolean separateTodoTypes(){
		
		assert(allTodoClone != null);
		assert(allTodo != null);
		assert(universalTodo != null);
		
		allTodo.clear();
		universalTodo.clear();
		
		for(Todo todo: allTodoClone){
			if(todo.hasDate()){
				allTodo.add(todo);
			} else{
				universalTodo.add(todo);
			}
		}
		return true;
	}
	
	public boolean setNewDirectory(String newBaseDirectory){
		if((newBaseDirectory != null) && (new File(newBaseDirectory).exists())){
			baseDirectory = newBaseDirectory.concat("/" + TODO + "/");
			return true;
		}
		return false;
	}
	
/***************************** Private methods sorted alphabetically ********************************/	
	
	private Calendar createDate(String dateString, Calendar date) {
		try {
			date = CalendarHelper.parseDate(dateString);
			setZeroTime(date);
		} catch (ParseException e) {
			myLogger.logp(Level.SEVERE, getClass().getName(), 
					"writeToFile", e.getMessage());
			return null;
		}
		return date;
	}
	
	private Todo createTodo(String todoName, String todoDate, String todoTime,
			String addInfo, String todoType, String Id, boolean isDone) {
		Todo todo;
		if(isPartialType(todoType)){
			todo = new Todo(todoName, addInfo, todoDate);
		
		}else if(isCompleteType(todoType)){
			todo = new Todo(todoName, addInfo, todoDate, todoTime);
			
		}else{
			todo = new Todo(todoName, addInfo);
		}
		
		todo.setId(Integer.parseInt(Id));
		todo.setDone(isDone);
		return todo;
	}
	
	private String determineType(Todo todo) {
		if(todo.hasDate() && todo.hasTime()){
			return COMPLETE_TODO_TYPE;
		}else if(todo.hasDate()){
			return PARTIAL_TODO_TYPE;
		}else{
			return BASIC_TODO_TYPE;
		}
	}
	
	private void extractTodoByDate(ArrayList<Todo> toDoListByDate, Calendar date) {
		
		assert(date != null);
		assert(toDoListByDate != null);
		
		ArrayList<Todo> myTodo = allTodo;
		Calendar todoDate;
		for(Todo todo: myTodo){
			todoDate = (Calendar) todo.getDeadline().clone();
			setZeroTime(todoDate);
			
			if( date.equals(todoDate) ){
				toDoListByDate.add(todo);
			}
		}
	}

	private boolean isCompleteType(String type){
		return type.equals(COMPLETE_TODO_TYPE);
	}
	
	private boolean isPartialType(String type){
		return type.equals(PARTIAL_TODO_TYPE);
	}
		
	private boolean readTodoFile(){				
		ArrayList<Todo> myTodo = new ArrayList<Todo>();
		String todoName, todoDate, todoTime, addInfo, todoType, Id;
		Todo todo;
		
		try {
			File inputFile = new File(baseDirectory + NORMAL_TODO);
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			boolean isDone;
			
			Id = reader.readLine();
			while( Id != null){
				
				todoType = reader.readLine();
				todoName = reader.readLine();
				todoDate = reader.readLine();
				todoTime = reader.readLine();
				isDone = Boolean.parseBoolean(reader.readLine());
				addInfo = "";
				
				todo = createTodo(todoName, todoDate, todoTime, addInfo,
						todoType, Id, isDone);
				myTodo.add(todo);
				Id = reader.readLine();
			}
			
			allTodo = myTodo;
			reader.close();		 
			return true;
		
		}catch (FileNotFoundException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readTodoFile", e.getMessage());
			saveChange(NORMAL_TODO);
			return false;
			
		}catch (Exception e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readTodoFile", e.getMessage());
			return false;
		}	
	}
	
	private boolean readUniversalTodoFile() {
		ArrayList<Todo> myUniversalTodo = new ArrayList<Todo>();
		String todoName, addInfo, Id;
		boolean isDone;
		
		try {
			File inputFile = new File(baseDirectory + FLOATING_TODO);
			BufferedReader reader = new BufferedReader(new FileReader(inputFile));
			String lineOfText;
			
			while( (lineOfText = reader.readLine()) != null ){
				Id = lineOfText;
				todoName = reader.readLine();
				isDone = Boolean.parseBoolean(reader.readLine());
				addInfo = "";
				
				Todo todo = new Todo(todoName, addInfo);
				todo.setId(Integer.parseInt(Id));
				todo.setDone(isDone);
				myUniversalTodo.add(todo);
			}
			
			universalTodo = myUniversalTodo;	
			reader.close();		 
			return true;
		}catch (FileNotFoundException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readUniversalTodoFile", e.getMessage());
			saveChange(FLOATING_TODO);
			return false;
		}catch (IOException e) {
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"readUniversalTodoFile", e.getMessage());
			return false;
		}	
	}
	
	private boolean retrievePassedTasks(){
		readUniversalTodoFile();
		readTodoFile();
		return true;
	}
	
	private void setZeroTime(Calendar date){
		
		assert(date != null);
		
		date.set(Calendar.HOUR_OF_DAY, 0);
		date.set(Calendar.MINUTE, 0);
		date.set(Calendar.SECOND, 0);
		date.set(Calendar.MILLISECOND, 0);
	}
	
	private void sortTodoByDate(ArrayList<Todo> toDoList){
		
		assert(toDoList != null);
		
		if(!toDoList.isEmpty()){
			Collections.sort(toDoList);
		}		
	}	
	
	private boolean writeToFile(String type){
		
		assert(type == NORMAL_TODO || type == FLOATING_TODO);
		
		try{
			File outfile = new File(baseDirectory +  type);
			BufferedWriter writer = new BufferedWriter(new FileWriter(outfile));	
			
			if(type.equals(NORMAL_TODO)){
				for(Todo aTodo : allTodo){
					writer.write(aTodo.getId() + ""); writer.newLine();
					String todoType = determineType(aTodo);
					writer.write(todoType); 
					writer.newLine();
					writer.write(aTodo.toString()); 
					writer.newLine();
					writer.write(aTodo.getDone() + "");
					writer.newLine();
				}
			}else{
				for(Todo aTodo : universalTodo){
					writer.write(aTodo.getId() + ""); 
					writer.newLine();
					writer.write(aTodo.getName()); 
					writer.newLine();
					writer.write(aTodo.getDone() + "");
					writer.newLine();
				}
			}	
			
			writer.close();
			return true;
	
		}catch(IOException e){
			myLogger.logp(Level.WARNING, getClass().getName(), 
					"writeToFile", e.getMessage());
			return false;
		}
	}
	
}
```
###### ./src/test/storage/DirectoryHandlerTest.java
``` java

package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.File;

import object.Item;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import storage.DirectoryHandler;

public class DirectoryHandlerTest {

	private static final String ALTERNATE_TEST_FILES = "alternateTestFiles";
	private static final String DATABASE = "database";
	private DirectoryHandler dirHand = new DirectoryHandler();
	private static String newBaseDirectory;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
		PreparationCleanUp.cleanUp(newBaseDirectory);
	}

	@Test
	public void testDirectoryHandler() {
		String baseDirectory = System.getProperty("user.dir").toString() + "/database";
		File file = new File(baseDirectory + "/Event");
		assertEquals("Test if Event directory exist",
				true, file.exists());
		
		file = new File(baseDirectory + "/Todo");
		assertEquals("Test if todo directory exist",
				true, file.exists());
		
		file = new File(baseDirectory + "/Project");
		assertEquals("Test if project directory exist",
				true, file.exists());
	}

	@Test
	public void testSetNewBaseDirectory() {
		
		newBaseDirectory = null;
		assertEquals("Test change to null directory",
				false, dirHand.setNewBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = "";
		assertEquals("Test change to empty directory",
				false, dirHand.setNewBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = "non-existing";
		assertEquals("Test change to non-existing directory",
				false, dirHand.setNewBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = "!@#$%^&*()";
		assertEquals("Test change to wrong format directory",
				false, dirHand.setNewBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = System.getProperty("user.dir").toString() + "/" + ALTERNATE_TEST_FILES + "/";
		PreparationCleanUp.makeNewDirectory(newBaseDirectory);
		assertEquals("Test with valid new directory",
				true, dirHand.setNewBaseDirectory(newBaseDirectory));
		testIfDirectoriesExist();
		
		assertEquals("Test with the same directory",
				false, dirHand.setNewBaseDirectory(newBaseDirectory));
		testIfDirectoriesExist();
	}

	private void testIfDirectoriesExist() {
		String baseDirectory = System.getProperty("user.dir").toString() + "/" + ALTERNATE_TEST_FILES;
		
		File file = new File(baseDirectory + "/" + DATABASE + "/Event");
		assertEquals("Test with valid new directory",
				true, file.exists());
		
		file = new File(baseDirectory + "/" + DATABASE + "/Todo");
		assertEquals("Test with valid new directory",
				true, file.exists());
		
		file = new File(baseDirectory + "/" + DATABASE + "/Project");
		assertEquals("Test with valid new directory",
				true, file.exists());
	}
		
}
```
###### ./src/test/storage/FileEventHandlerTest.java
``` java
package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;

import object.Event;
import object.Item;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import storage.FileEventHandler;

public class FileEventHandlerTest {

	private static String baseDirectory;
	private static FileEventHandler fEventH;	
	
	private Event event = new Event("Event1", "31 aug 2100 23:00", "1 sep 2100 02:00");
	private Event event2 = new Event("Event2", "20 aug 2000 23:00", "21 aug 2000 02:00");
	
	@Before
	public void setUpBeforeMethod() throws Exception{
		Item.setCounter(0);
		baseDirectory = System.getProperty("user.dir").toString() + "/testFiles";
		PreparationCleanUp.manualCleanUp();
		PreparationCleanUp.cleanUp(baseDirectory);
		PreparationCleanUp.setUpDirectory(baseDirectory);
	}
	
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
		PreparationCleanUp.cleanUp(baseDirectory);
	}
	
	@Test
	public void testFileEventHandlerInIdealSequence(){
		testFileEventHandlerConstructor();
		testSaveNewEventHandler();
		testRetrieveEventByDate();
		testRetrieveAllEvents();
		testChangeDirectory();
	}
	
	@Test
	public void testRetrieveEventByDateWithNoExistingEvent(){
		fEventH = new FileEventHandler(baseDirectory);
		ArrayList<Event> actualEventBook = fEventH.retrieveEventByDate("20 aug 2000");
		
		assertEquals("Test retrieving from a date with no event",
				new ArrayList<Event>(), actualEventBook);
	}
	
	@Test
	public void testRetrieveAllEventsWithNoEvent(){
		fEventH = new FileEventHandler(baseDirectory);
		assertEquals("Test retrieval of all events when there are no existing events",
				new ArrayList<Event>(), fEventH.retrieveAllEvents());
	}
	
/**********************************************************************************************/
	
	private void testFileEventHandlerConstructor() {
		fEventH = new FileEventHandler(baseDirectory);
		
		assertEquals("Test if the event txt file has been created",
				true, new File(baseDirectory + "/All_Events.txt").exists());
		
		assertEquals("Test if there are no existing events", 
				new ArrayList<Event>(), fEventH.retrieveAllEvents());
		
	}
	
	private void testSaveNewEventHandler() {
		
//		assertEquals("Test saving null event",
//				false, fEventH.saveNewEventHandler(null));
		
		assertEquals("Test saving valid event",
				true, fEventH.saveNewEventHandler(event));
		
		assertEquals("Test saving valid passed event",
				true, fEventH.saveNewEventHandler(event2));
	}
	
	private void testRetrieveEventByDate() {
				
		assertEquals("Test retrieving from a date with wrong format: numbers",
				null, fEventH.retrieveEventByDate("1234567"));
		
		assertEquals("Test retrieving from a date with wrong format: symbols",
				null, fEventH.retrieveEventByDate(")(*&^%$#@!"));
		
		assertEquals("Test retrieving from a non-existing date",
				null, fEventH.retrieveEventByDate("95 mar 2100"));
		
		assertEquals("Test retrieving from a date with no event",
				new ArrayList<Event>(), fEventH.retrieveEventByDate("12 mar 2100"));

		ArrayList<Event> expectedEventBook = new ArrayList<Event>();
		expectedEventBook.add(event2);
		ArrayList<Event> actualEventBook = fEventH.retrieveEventByDate("20 aug 2000");
	
		assertEquals("Test retrieving from a date of the past",
				expectedEventBook, actualEventBook);
	}
	
	private void testChangeDirectory(){
		PreparationCleanUp.cleanUp(baseDirectory);
		testSetNewDirectory();
		// new directory would be set at this point.
		PreparationCleanUp.makeNewDirectory(baseDirectory + "/Event");
		testSaveEventBook(true);
		
		//test if data has been transferred.
		testRetrieveEventByDate();
		testRetrieveAllEvents();
		
		// pseudo-reset to re-start up FileEventHandler to test for data persistence.
		fEventH = new FileEventHandler(baseDirectory + "/Event");
		testRetrieveEventByDate();
		testRetrieveAllEvents();
	}
	
	private void testSetNewDirectory() {
		String newBaseDirectory = null;
		assertEquals("Test with new directory being null",
				false, fEventH.setNewDirectory(newBaseDirectory));
		
		newBaseDirectory = "this is not a directory format";
		assertEquals("Test if new directory does not exist",
				false, fEventH.setNewDirectory(newBaseDirectory));
		
		newBaseDirectory = System.getProperty("user.dir").toString() + "/alternateTestFiles";
		PreparationCleanUp.makeNewDirectory(newBaseDirectory);
		assertEquals("Test with valid new directory",
				true, fEventH.setNewDirectory(newBaseDirectory));
		baseDirectory = newBaseDirectory;
	}

	private void testRetrieveAllEvents() {
		ArrayList<Event> expectedList = new ArrayList<Event>();
		event.setId(0);
		event2.setId(1);
		expectedList.add(event2);
		expectedList.add(event);
		
		assertEquals("Test retrieval of all events",
				expectedList, fEventH.retrieveAllEvents());
			
	}
	
	private void testSaveEventBook(boolean bool){
		assertEquals("Test saveEventBook",
				bool, fEventH.saveEventBook());
	}
	
}




```
###### ./src/test/storage/FileHandlerTest.java
``` java
package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

import object.Event;
import object.Item;
import object.Todo;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import storage.FileHandler;


public class FileHandlerTest {
	private static FileHandler fh;
	private static String newBaseDirectory;
	private static final String DATABASE = "database";
	
	private Todo todo1 = new Todo("Floating todo");
	private Todo todo2 = new Todo("Normal todo1", "", "20 Oct 2100");
	private Todo todo3 = new Todo("Past todo1", "", "20 Oct 2000");
	private Todo todo4 = new Todo("Normal todo2", "", "20 Oct 2100", "10:00");
	private Todo todo5 = new Todo("past todo2", "", "20 Oct 2000", "10:00");
	private Todo todo6 = new Todo("Normal todo3", "", "20 Oct 2100", "07:30");
	private Todo todo7 = new Todo("Past todo3", "", "20 Oct 2000", "07:30");
	
	private ArrayList<Todo> expectedList;
	private ArrayList<Todo> actualList;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
		fh = new FileHandler();
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
		PreparationCleanUp.cleanUp(newBaseDirectory);
	}
	
	@Test
	public void testFileHandlerInIdealSequence(){
		testFileHandler();
		testChangeBaseDirectory();
		
		testEventOperation();
		fh = new FileHandler();
		testTodoOperation();
		fh = new FileHandler();
		testProjectOperation();
		
	}
	
	public void testFileHandler() {
		String baseDirectory = System.getProperty("user.dir").toString();
		File file = new File(baseDirectory + "/database/Event");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/database/Event/All_Events.txt");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/database/Todo");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/database/Todo/Floating_Todo.txt");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/database/Todo/Normal_Todo.txt");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/database/Project");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/database/Project/projectOverviewer.txt");
		assertEquals("Test file existence",
				true, file.exists());
		
		file = new File(baseDirectory + "/overview.txt");
		assertEquals("Test file existence",
				true, file.exists());
	}

/****************************************************************************/		

	public void testEventOperation(){
		testSaveNewEventHandler();
		testRetrieveAllEvents();
		testRetrieveAllEvents();
	}
	
	public void testRetrieveEventByDate() {
		assertEquals("Test retrieving from null date",
				new ArrayList<Event>(), fh.retrieveEventByDate(null));
		
		assertEquals("Test retrieving from a date with no event",
				new ArrayList<Event>(), fh.retrieveEventByDate("12 mar 2100"));
	
		Event event = new Event("Event2", "20 aug 2000 23:00", "21 aug 2000 02:00");
		event.setId(1);
		ArrayList<Event> expectedEventBook = new ArrayList<Event>();
		expectedEventBook.add(event);
		ArrayList<Event> actualEventBook = fh.retrieveEventByDate("20 aug 2000");
		
//		assertEquals("Test retrieving from a date of the past",
//				true, compareEventsArrayList(expectedEventBook,actualEventBook) );
	
		assertEquals("Test retrieving from a date of the past",
				expectedEventBook,actualEventBook);
	}

	public void testRetrieveAllEvents() {
		ArrayList<Event> expectedList = new ArrayList<Event>();
		Event event = new Event("Event1", "31 aug 2100 23:00", "1 sep 2100 02:00");
		Event event2 = new Event("Event2", "20 aug 2000 23:00", "21 aug 2000 02:00");
		event.setId(7);
		event2.setId(8);
		expectedList.add(event2);
		expectedList.add(event);
		
		assertEquals("Test retrieval of all events", 
				expectedList, fh.retrieveAllEvents());
	}
	
	public void testSaveNewEventHandler() {
		assertEquals("Test saving null event",
				false, fh.saveNewEventHandler(null));
		
		Event event = new Event("Event1", "31 aug 2100 23:00", "1 sep 2100 02:00");
		
		assertEquals("Test saving valid event",
				true, fh.saveNewEventHandler(event));
		
		Event event2 = new Event("Event2", "20 aug 2000 23:00", "21 aug 2000 02:00");
		
		assertEquals("Test saving valid past event",
				true, fh.saveNewEventHandler(event2));
	}

/****************************************************************************/
		
	public void testTodoOperation(){
		testSaveNewTodoHandler();
		testRetrieveUniversalTodo();
		testRetrieveAllTodo();
		testRetrieveTodoByDate();
		testSaveEditedTodoHandler();
		testSaveAllEditedTodo();
	}
	
	//tested with null, past and future dates
	public void testRetrieveTodoByDate() {
		ArrayList<Todo> expectedList = new ArrayList<Todo>();
		
		ArrayList<Todo> actualList = fh.retrieveTodoByDate(null);
		assertEquals("Test retrieval of todo with null", 
				null, actualList);
		
		actualList = fh.retrieveTodoByDate("01 Jan 2000");
		assertEquals("Test retrieval of todo on date with no todo", 
				expectedList, actualList);
		
		expectedList.add(todo3);
		expectedList.add(todo7);
		expectedList.add(todo5);
		
		
		actualList = fh.retrieveTodoByDate("20 oct 2000");
		assertEquals("Test retrieval of passed todo by date", 
				true, compareArrayList(expectedList, actualList));
		
		expectedList.clear();
		expectedList.add(todo2);
		expectedList.add(todo6);
		expectedList.add(todo4);
		
		
		actualList = fh.retrieveTodoByDate("20 oct 2100");
		assertEquals("Test retrieval of future todo by date", 
				true, compareArrayList(expectedList, actualList));
	}

	public void testRetrieveAllTodo() {
		ArrayList<Todo> expectedList = new ArrayList<Todo>();
		expectedList.add(todo1);
		expectedList.add(todo2);
		expectedList.add(todo3);
		expectedList.add(todo4);
		expectedList.add(todo5);
		expectedList.add(todo6);
		expectedList.add(todo7);
		
		ArrayList<Todo> actualList = fh.retrieveAllTodo();
		
		assertEquals("Test retrieval of all todo", 
				true, compareArrayList(expectedList, actualList));
	}

	public void testRetrieveUniversalTodo() {
		expectedList = new ArrayList<Todo>();		
		expectedList.add(todo1);
		actualList = fh.retrieveUniversalTodo();
		
		assertEquals("Test retrieval of all floating todo", 
				expectedList, actualList);
	}

	public void testSaveNewTodoHandler() {
		
		assertEquals("Test adding of floating todo", 
				false, fh.saveNewTodoHandler(null));
		
		assertEquals("Test adding of floating todo", 
				true, fh.saveNewTodoHandler(todo1));
		
		assertEquals("Test adding of normal todo with no time", 
				true, fh.saveNewTodoHandler(todo2));
		
		assertEquals("Test adding of passed todo with no time", 
				true, fh.saveNewTodoHandler(todo3));
		
		assertEquals("Test adding of normal todo", 
				true, fh.saveNewTodoHandler(todo4));
		
		assertEquals("Test adding of passed todo", 
				true, fh.saveNewTodoHandler(todo5));
		
		//change bottom todo to current date?
		
		assertEquals("Test adding of normal todo", 
				true, fh.saveNewTodoHandler(todo6));
		
		assertEquals("Test adding of passed todo", 
				true, fh.saveNewTodoHandler(todo7));	
	}
	
	public void testSaveEditedTodoHandler() {
		
		assertEquals("Test save when there are no change done",
				true, fh.saveEditedTodoHandler());
		
		ArrayList<Todo> todolist = fh.retrieveAllTodo();
		Todo todo = todolist.get(0);
		todo.setName("eventful");
		assertEquals("Test if save is successful after editing the event", 
				true, fh.saveEditedTodoHandler());
		
		todolist = fh.retrieveAllTodo();
		todo2 = todolist.get(0);
		assertEquals("Test if changes are saved",
				todo, todo2);		
	}

	public void testSaveAllEditedTodo() {
		assertEquals("Test save when there are no change done",
				true, fh.saveAllEditedTodo());
		
		ArrayList<Todo> todolist = fh.retrieveAllTodo();
		Todo todo = todolist.get(0);
		todo.setName("todo7");
		assertEquals("Test if save is successful after editing the event", 
				true, fh.saveAllEditedTodo());
		
		todolist = fh.retrieveAllTodo();
		todo2 = todolist.get(0);
		assertEquals("Test if changes are saved",
				todo, todo2);		
	}
	
/***************************************************************************/
	
	public void testProjectOperation(){
		testGetListOfExistingProjectWithNoProject();
		testCreateNewProject();
		testGetListOfExistingProject();
		testSaveEditedProjectDetails();
		testDeleteProject();
		
	}
	
	@Test
	public void testRetrieveProjectTimeLine() {
		assertEquals("Test retrieval of project with null",
				null, fh.retrieveProjectTimeLine(null));
		
		assertEquals("Test retrieval of project with empty string",
				new ArrayList<Integer>(), fh.retrieveProjectTimeLine(""));
		
		assertEquals("Test retrieval of project with non-existing project name",
				new ArrayList<Integer>(), fh.retrieveProjectTimeLine("Non-existing"));
		
		fh.createNewProject("new project");
		ArrayList<Integer> projectBook = new ArrayList<Integer>();
		projectBook.add(0);
		fh.saveEditedProjectDetails(projectBook, new HashMap<Integer, String>(), "new project");
		
		assertEquals("Test retrieval of existing project",
				projectBook, fh.retrieveProjectTimeLine("new project"));
		
	}

	@Test
	public void testRetrieveProjectProgress() {
		assertEquals("Test retrieval without have to first retrieve project",
				new HashMap<Integer, String>(), fh.retrieveProjectProgress());
	}
	
	public void testCreateNewProject() {
		
		assertEquals("adding of project with null name",
				false, fh.createNewProject(null));
		
		assertEquals("adding of project with symbol name", 
				false, fh.createNewProject("!@#$%^&*()"));
		
		assertEquals("adding of project with empty string name",
				false, fh.createNewProject(""));
		
		assertEquals("adding of project", 
				true, fh.createNewProject("proj1"));
		
		assertEquals("adding of project with the same name",
				false, fh.createNewProject("proj1"));
		
		assertEquals("adding of project with similar name",
				true, fh.createNewProject("proj12"));
		
		assertEquals("adding of project with number name",
				true, fh.createNewProject("1234567890"));
			
	}

	public void testSaveEditedProjectDetails() {
				
		HashMap<Integer, String> progressBook  = new HashMap<Integer, String>();
		progressBook.put(1, "progress1");
		progressBook.put(4, "this index should not exist");
		ArrayList<Integer> projectBook = new ArrayList<Integer>();
		projectBook.add(1);
		String projectName = "proj1";
		
		assertEquals("Testing of editing with null projectBook",
				false, fh.saveEditedProjectDetails(null, progressBook, projectName) );
		
		assertEquals("Testing of editing with null progressBook",
				false, fh.saveEditedProjectDetails(projectBook, null, projectName) );
		
		assertEquals("Testing of editing with null name",
				false, fh.saveEditedProjectDetails(projectBook, progressBook, null) );
		
		assertEquals("Testing of editing with empty name",
				false, fh.saveEditedProjectDetails(projectBook, progressBook, "") );
		
		assertEquals("Testing of editing with non-existing project name",
				false, fh.saveEditedProjectDetails(projectBook, progressBook, "non-existing"));
		
		assertEquals("Testing of editing with valid parameters",
				true, fh.saveEditedProjectDetails(projectBook, progressBook, projectName) );
		
		progressBook.put(4, "this index should not exist");
		
		//In this case, FileHandler does not check if the id is valid, Logic will handle it.
		assertEquals("Testing of editing with hashmap having ID that does not exist in projectBook",
				true, fh.saveEditedProjectDetails(projectBook, progressBook, projectName) );
		
		Item.setCounter(0); 	//reset Counter for other test cases
	}

	public void testGetListOfExistingProjectWithNoProject() {	
		assertEquals("Test the retrieval of list when there is no existing project",
				new ArrayList<String>(), fh.getListOfExistingProject());
	}
	
	public void testGetListOfExistingProject() {
		ArrayList<String> expectedList = new ArrayList<String>();
		expectedList.add("proj1");
		expectedList.add("proj12");
		expectedList.add("1234567890");
		assertEquals("Test the retrieval of list when there is no existing project",
				expectedList, fh.getListOfExistingProject());
		
	}

	public void testDeleteProject() {
		assertEquals("Test deleting of project with null",
				false, fh.deleteProject(null));
		assertEquals("Test deleting of project with empty string",
				false, fh.deleteProject(""));
		assertEquals("Test deleting of non-existing project",
				false, fh.deleteProject("non-existing project name"));
			
		assertEquals("Test deleting of existing project with number names",
				true, fh.deleteProject("1234567890"));
		assertEquals("Test deleting of project with similar names",
				true, fh.deleteProject("proj12"));
		assertEquals("Test deleting of project",
				true, fh.deleteProject("proj1"));
		

		testGetListOfExistingProjectWithNoProject(); 
		// test if the projects names are also deleted from the project overview file
		
	}

/***************************************************************************/
	
	public void testChangeBaseDirectory() {
		newBaseDirectory = null;
		assertEquals("Test change to null directory",
				false, fh.changeBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = "";
		assertEquals("Test change to empty directory",
				false, fh.changeBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = "non-existing";
		assertEquals("Test change to non-existing directory",
				false, fh.changeBaseDirectory(newBaseDirectory));
		
		newBaseDirectory = System.getProperty("user.dir").toString() + "/alternateTestFiles";
		PreparationCleanUp.makeNewDirectory(newBaseDirectory);
		
		
		assertEquals("Test with valid new directory",
				true, fh.changeBaseDirectory(newBaseDirectory));
		
		File file = new File(newBaseDirectory);
		assertEquals("Test if event directory exist",
				true, file.exists());
		
		file = new File(newBaseDirectory + "/database");
		assertEquals("Test if event directory exist",
				true, file.exists());
		
		file = new File(newBaseDirectory + "/database/Event");
		assertEquals("Test if event directory exist",
				true, file.exists());
		
		file = new File(newBaseDirectory + "/database/Todo");
		assertEquals("Test if todo directory exist",
				true, file.exists());
		
		file = new File(newBaseDirectory + "/database/Project");
		assertEquals("Test if project directory exist",
				true, file.exists());
	}

//	@Test
//	public void testSaveAll() {
//		assertEquals("testing of saving all",
//				true, fh.saveAll());
//	}
			
	@Test
	public void testClearAll() {
		fh.clearAll();
		checkIfDirectoriesExist(false);	// expect false since fh has clear all files
		fh = new FileHandler();	
		checkIfDirectoriesExist(true);	// fh will re-create files
	}

	@Test
	public void testRetrieveEventById() {
		
		Event event = new Event("Event1", "31 aug 2100 23:00", "1 sep 2100 02:00");
		assertEquals("Test save of new event",
				true, fh.saveNewEventHandler(event));
		
		assertEquals("Test retrieval of event with a valid index",
				event, fh.retrieveEventById(event.getId()));
		
		assertEquals("Test retrieval of event with negative index number",
				null, fh.retrieveEventById(-1));
		
		assertEquals("Test retrieval of event with an invalid index",
				null, fh.retrieveEventById(1000));
		
		Item.setCounter(0);
	}

	@Test
	public void testRetrieveTaskById() {
		Item.setCounter(0);
		Todo todo1 = new Todo("Floating todo");
		Todo todo2 = new Todo("Normal todo1", "", "20 Oct 2100");		
		
		assertEquals("Test creation of new floating todo",
				true, fh.saveNewTodoHandler(todo1));
		
		assertEquals("Test creation of new normal todo",
				true, fh.saveNewTodoHandler(todo2));
		
		assertEquals("Test retrieval of floating todo with valid index",
				todo1, fh.retrieveTaskById(todo1.getId()));
		
		assertEquals("Test retrieval of normal todo with valid index",
				todo2, fh.retrieveTaskById(todo2.getId()));
		
		assertEquals("Test retrieval of todo with negative index",
				null, fh.retrieveTaskById(-1));
		
		assertEquals("Test retrieval of todo with invalid index",
				null, fh.retrieveTaskById(1000));
		
		
	}
	
	public void checkIfDirectoriesExist(boolean expected){
		String baseDirectory = System.getProperty("user.dir").toString();
		
		File file = new File(baseDirectory + "/" + DATABASE + "/Event");
		assertEquals("Test if event storage directory exist",
				expected, file.exists());
		
		file = new File(baseDirectory + "/" + DATABASE + "/Todo");
		assertEquals("Test if todo storage directory exist",
				expected, file.exists());
		
		file = new File(baseDirectory + "/" + DATABASE + "/Project");
		assertEquals("Test if project directory directory exist",
				expected, file.exists());

	}

	// Todo without time specified will be set to the current time, hence sorted order may differ.
	// Use this method to compare todo arrayList instead.
	private boolean compareArrayList(ArrayList<Todo> list1, ArrayList<Todo> list2){
		if(list1.size() == list2.size()){
			for(Todo todo: list1){
				if(!list2.contains(todo)){
					return false;
				}
			}
			return true;
		}else{
			return false;
		}	
	}
}
```
###### ./src/test/storage/FileProjectHandlerTest.java
``` java
package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

import object.Item;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import storage.FileProjectHandler;

public class FileProjectHandlerTest {
	
	private static final String PROJECT_OVERVIEWER = "/projectOverviewer.txt";
	private static String baseDirectory;
	private static FileProjectHandler fProjH;	

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		baseDirectory = System.getProperty("user.dir").toString() + "/testFiles";
		Item.setCounter(0);
		PreparationCleanUp.cleanUp(baseDirectory);
		PreparationCleanUp.setUpDirectory(baseDirectory);
		
	}
	
	@Test
	public void testFileProjectHandlerInIdealSequence(){
		testFileProjectHandlerConstructor();
		testCreateNewProject();
		testDeleteProject();
		testSaveEditedProjectDetails();
		testRetrieveProject();
		testRetrieveProjectProgress();
		testGetListOfExistingProjects();
		testChangeDirectory();
	}
	
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
		PreparationCleanUp.cleanUp(baseDirectory);
	}
	
/*****************************************************************************/
	
	public void testFileProjectHandlerConstructor() {
		fProjH = new FileProjectHandler(baseDirectory);

		File overviewFile = new File(baseDirectory + PROJECT_OVERVIEWER);
		
		assertEquals("Check if overview file exist", 
				true, overviewFile.exists());
		
		assertEquals("Check if there are no existing project", 
				new ArrayList<String>(), fProjH.getListOfExistingProjects());

	}
	
	public void testCreateNewProject() {
		assertEquals("Test adding null project name", 
				false, fProjH.createNewProject(null));
		
		assertEquals("Test adding valid project name", 
				true, fProjH.createNewProject("project1"));
		
		assertEquals("Test adding repeated project name", 
				false, fProjH.createNewProject("project1"));
	}

	public void testDeleteProject() {
		fProjH.createNewProject("project to be deleted");
		
		assertEquals("Test delete project by name", 
				true, fProjH.deleteProject("project to be deleted"));
		
		assertEquals("Test delete non-existing project", 
				false, fProjH.deleteProject("non-existing project"));
		
		assertEquals("Test delete project with null", 
				false, fProjH.deleteProject(null));		
	}
	
	public void testSaveEditedProjectDetails() {
		HashMap<Integer, String> progressBook = new HashMap<Integer, String>();
		ArrayList<Integer> projectBook = fProjH.retrieveProject("project1");
		
		projectBook.add(1); 
		progressBook.put(1, "one");
		
		projectBook.add(2); 
		progressBook.put(2, "two");
		
		projectBook.add(3); 
		progressBook.put(3, "three");
		
		assertEquals("Test saving", 
				true, fProjH.saveEditedProjectDetails(projectBook, progressBook, "project1"));

	}
	
	public void testRetrieveProject() {
		ArrayList<Integer> expectedProjEventId = new ArrayList<Integer>();
		expectedProjEventId.add(1);
		expectedProjEventId.add(2);
		expectedProjEventId.add(3);
		
		assertEquals("Test retrieving", 
				expectedProjEventId, fProjH.retrieveProject("project1"));
		
		assertEquals("Test retrieval of non-existing project", 
				new ArrayList<Integer>(), fProjH.retrieveProject("non-existing project"));
		
		assertEquals("Test retrieval with projects name with symbols",
				new ArrayList<Integer>(), fProjH.retrieveProject("!@#$"));
	}

	public void testRetrieveProjectProgress() {
		HashMap<Integer, String> progressBook = new HashMap<Integer, String>();
		
		assertEquals("Test retrieval of progress from non-existing project", 
				progressBook, fProjH.retrieveProjectProgress());
		
		progressBook.put(1, "one");
		progressBook.put(2, "two");
		progressBook.put(3, "three");
		fProjH.retrieveProject("project1");
		
		assertEquals("Test retrieval of progress from non-existing project", 
				progressBook, fProjH.retrieveProjectProgress());
		

		fProjH.createNewProject("project2");
		fProjH.retrieveProject("project2");
		progressBook.clear();
		
		assertEquals("Test retrieval of empty event progress", 
				progressBook, fProjH.retrieveProjectProgress());
		
	}
	
	public void testGetListOfExistingProjects() {
		
		ArrayList<String> expectedExistingProjects = new ArrayList<String>();
		expectedExistingProjects.add("project1");
		expectedExistingProjects.add("project2");
		
		assertEquals("Test retrieval of names of existing project", 
				expectedExistingProjects, fProjH.getListOfExistingProjects());
	}

	public void testSetNewDirectory() {
		String newBaseDirectory = null;
		assertEquals("Test with new directory being null",
				false, fProjH.setNewDirectory(newBaseDirectory));
		
		newBaseDirectory = "this is not a directory format";
		assertEquals("Test if new directory does not exist",
				false, fProjH.setNewDirectory(newBaseDirectory));
		
		newBaseDirectory = System.getProperty("user.dir").toString() + "/alternateTestFiles";
		PreparationCleanUp.makeNewDirectory(newBaseDirectory);
		assertEquals("Test with valid new directory",
				true, fProjH.setNewDirectory(newBaseDirectory));
		baseDirectory = newBaseDirectory;

	}

	public void testReadAll() {
		assertEquals("Test readAll method",
				true, fProjH.readAll());
	}

	public void testWriteAll() {
		assertEquals("Test writeAll method",
				true, fProjH.writeAll());
	}
	
	public void testChangeDirectory(){
		testReadAll();
		PreparationCleanUp.cleanUp(baseDirectory);
		testSetNewDirectory();
		//new directory would be set at this point
		PreparationCleanUp.makeNewDirectory(baseDirectory + "/Project");
		testWriteAll();
		
		//re-test retrieval
		fProjH = new FileProjectHandler(baseDirectory + "/Project");
		testRetrieveProject();
		testRetrieveProjectProgress();
		testGetListOfExistingProjects();
	}

}
```
###### ./src/test/storage/FileTodoHandlerTest.java
``` java
package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;

import object.Item;
import object.Todo;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import storage.FileTodoHandler;


public class FileTodoHandlerTest {
	
	private static final String FLOATING_TODO = "Floating_Todo.txt";
	private static final String NORMAL_TODO = "Normal_Todo.txt";
	
	private static String baseDirectory;
	private static FileTodoHandler fTodoH;
	
	private Todo todo1 = new Todo("Floating todo");
	private Todo todo2 = new Todo("Normal todo1", "", "20 oct 2100");
	private Todo todo3 = new Todo("Past todo1", "", "20 oct 2000");
	private Todo todo4 = new Todo("Normal todo2", "", "20 oct 2100", "10:00");
	private Todo todo5 = new Todo("past todo2", "", "20 oct 2000", "10:00");
	private Todo todo6 = new Todo("Normal todo3", "", "20 oct 2100", "07:30");
	private Todo todo7 = new Todo("Past todo3", "", "20 oct 2000", "07:30");
	
	private ArrayList<Todo> expectedList;
	private ArrayList<Todo> actualList;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		baseDirectory = System.getProperty("user.dir").toString() + "/testFiles";
		Item.setCounter(0);
		PreparationCleanUp.cleanUp(baseDirectory);
		PreparationCleanUp.setUpDirectory(baseDirectory);
	}
	
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		Item.setCounter(0);
		PreparationCleanUp.manualCleanUp();
		PreparationCleanUp.cleanUp(baseDirectory);
	}
	
	@Test
	public void testFileTodoHandlerInIdealSequence(){
		testFileTodoHandlerConstructor();
		testSaveNewTodoHandler();
		testRetrieveAllTodo();
		testRetrieveTodoByDate();
		testRetrieveFloatingTodo();
		testSaveChange();
		testChangeDirectory();
	}
	
	@Test
	public void testRetrievalWithNoTask(){
		PreparationCleanUp.cleanUp(baseDirectory);
		fTodoH = new FileTodoHandler(baseDirectory);
		
		ArrayList<Todo> expectedList = new ArrayList<Todo>();
		ArrayList<Todo> actualList = fTodoH.retrieveAllTodo();
		
		assertEquals("Test retrieval of all todo", 
				expectedList, actualList);
		
		Item.setCounter(0);
		PreparationCleanUp.cleanUp(baseDirectory);
		PreparationCleanUp.setUpDirectory(baseDirectory);
	}
	
/****************************************************************************/
	
	// Todo without time specified will be set to the current time, hence sorted order may differ.
	// Use this method to compare todo arrayList instead.
	private boolean compareArrayList(ArrayList<Todo> list1, ArrayList<Todo> list2){
		if(list1.size() == list2.size()){
			for(Todo todo: list1){
				if(!list2.contains(todo)){
					return false;
				}
			}
			return true;
		}else{
			return false;
		}	
	}
	
	private void testFileTodoHandlerConstructor() {
		fTodoH = new FileTodoHandler(baseDirectory);
		
		assertEquals("Test if the floating txt file has been created",
				true, new File(baseDirectory + "/Floating_Todo.txt").exists());
		
		assertEquals("Test if the floating txt file has been created",
				true, new File(baseDirectory + "/Normal_Todo.txt").exists());
		
		assertEquals("Test if there are no existing tasks", 
				new ArrayList<Todo>(), fTodoH.retrieveAllTodo());
		
	}

	private void testSaveNewTodoHandler() {
		
		assertEquals("Test adding of todo1", 
				true, fTodoH.saveNewTodoHandler(todo1));
		
		assertEquals("Test adding of todo2", 
				true, fTodoH.saveNewTodoHandler(todo2));
		
		assertEquals("Test adding of todo3", 
				true, fTodoH.saveNewTodoHandler(todo3));
		
		assertEquals("Test adding of todo4", 
				true, fTodoH.saveNewTodoHandler(todo4));
		
		assertEquals("Test adding of todo5", 
				true, fTodoH.saveNewTodoHandler(todo5));
		
		assertEquals("Test adding of todo6", 
				true, fTodoH.saveNewTodoHandler(todo6));
		
		assertEquals("Test adding of todo7", 
				true, fTodoH.saveNewTodoHandler(todo7));	
	}
	
	private void testRetrieveAllTodo() {
		ArrayList<Todo> expectedList = new ArrayList<Todo>();
		
		expectedList.add(todo7);
		
		expectedList.add(todo5);
		expectedList.add(todo3);
		expectedList.add(todo6);
		
		expectedList.add(todo4);
		expectedList.add(todo2);
		expectedList.add(todo1);
		
		ArrayList<Todo> actualList = fTodoH.retrieveAllTodo();
		
		assertEquals("Test retrieval of all todo",
				true, compareArrayList(expectedList, actualList));
	}

	private void testRetrieveTodoByDate() {
		ArrayList<Todo> expectedList = new ArrayList<Todo>();
				
		expectedList.add(todo7);
		expectedList.add(todo5);
		expectedList.add(todo3);
		
		actualList = fTodoH.retrieveTodoByDate("20 oct 2000");
		assertEquals("Test retrieval of todo by date",
				true, compareArrayList(expectedList, actualList));
	}

	private void testRetrieveFloatingTodo() {
		expectedList = new ArrayList<Todo>();
		expectedList.add(todo1);
		actualList = fTodoH.retrieveFloatingTodo();
			
		assertEquals("Test retrieval of all floating todo", 
				expectedList, actualList);
	}

	private void testSetNewDirectory() {
		String newBaseDirectory = null;
		assertEquals("Test with new directory being null",
				false, fTodoH.setNewDirectory(newBaseDirectory));
		
		newBaseDirectory = "this is not a directory format";
		assertEquals("Test if new directory does not exist",
				false, fTodoH.setNewDirectory(newBaseDirectory));
		
		newBaseDirectory = System.getProperty("user.dir").toString() + "/alternateTestFiles";
		PreparationCleanUp.makeNewDirectory(newBaseDirectory);
		assertEquals("Test with valid new directory",
				true, fTodoH.setNewDirectory(newBaseDirectory));
		baseDirectory = newBaseDirectory;
	}
	
	private void testChangeDirectory(){
		PreparationCleanUp.cleanUp(baseDirectory);
		testSetNewDirectory();
		PreparationCleanUp.makeNewDirectory(baseDirectory + "/Todo");
		testSaveChange();
		
		fTodoH = new FileTodoHandler(baseDirectory + "/Todo");
		testRetrieveAllTodo();
		testRetrieveTodoByDate();
		testRetrieveFloatingTodo();
	}
	
	private void testSaveChange(){
		assertEquals("Test saving floating task",
				true, fTodoH.saveChange(FLOATING_TODO));
		assertEquals("Test saving normal task",
				true, fTodoH.saveChange(NORMAL_TODO));
	}
	
}
```
###### ./src/test/storage/PreparationCleanUp.java
``` java

package test.storage;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class PreparationCleanUp {
	
	public static boolean cleanUp(String baseDirectory){
		try {		
			File dir = new File(baseDirectory);
			if(dir.isDirectory() && dir.list().length > 0){
				for(File file: dir.listFiles()) {
					if(!file.isDirectory()){
						file.delete(); 
					}else{
						cleanUp(file.getPath());
					}
				}
			}
			
			Path path = Paths.get(baseDirectory);
		
		
			Files.delete(path);
			return true;
		} catch(NoSuchFileException e) {
			System.out.println("No such file exist to delete");
		}catch(Exception e){
			e.printStackTrace();
		}
		return false;
	}
	
	public static boolean setUpDirectory(String baseDirectory){
		File dir = new File(baseDirectory);
		if (!dir.exists()) {
			dir.mkdir();
			return true;
		}		
		return false;
	}

	public static boolean makeNewDirectory(String directoryName){
		File file = new File(directoryName);
		if (!file.exists()) {
			return file.mkdir();
		}
		return false;
	}

	public static void manualCleanUp(){
		delete("database");
		delete("overview.txt");	
		delete("Counter.txt");	
	}
		
	private static void delete(String name){
		String baseDirectory = System.getProperty("user.dir").toString() + "/" + name;
		File file = new File(baseDirectory);
		if(file.isDirectory()){
			cleanUp(baseDirectory);
		}else{
			file.delete();
		}
	}
}
```
