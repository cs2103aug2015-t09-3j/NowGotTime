# A0130445R
###### ./src/object/Event.java
``` java

package object;
import helper.CalendarHelper;

import java.text.ParseException;
import java.util.Calendar;

/**
 * Assumption is that the time and date format goes as follow:
 * 1) date: dd mm yyyy
 * 2) time: hhmm
 * 
 */

public class Event extends Item {

    private Calendar start;
    private Calendar end;

    /*********************************** Constructor ******************************************/

    public Event(String name, String date, String startTime, String endTime, String additionalInfo){
        this(name, date, date, startTime, endTime, additionalInfo);
    }

    public Event(String name, String startDate, String endDate, String startTime, String endTime, String additionalInfo ){
        super(name, additionalInfo);

        start = Calendar.getInstance();
        end = Calendar.getInstance();

        CalendarHelper.updateDate(start, startDate);
        CalendarHelper.updateTime(start, startTime);
        CalendarHelper.updateDate(end, endDate);
        CalendarHelper.updateTime(end, endTime);

    }

    public Event(String name, String startDateTime, String endDateTime) {
        super(name , "");

        start = Calendar.getInstance();
        end = Calendar.getInstance();

        CalendarHelper.updateDateTime(start, startDateTime);
        CalendarHelper.updateDateTime(end, endDateTime);
    }

    /*********************************** Accessors ********************************************/

    public Calendar getStartCalendar(){
        return start;
    }

    public Calendar getEndCalendar(){
        return end;
    }

    public String getStartDateString() {
        return CalendarHelper.getDateString(start);
    }

    public String getEndDateString() {
        return CalendarHelper.getDateString(end);
    }

    public String getStartTimeString() {
        return CalendarHelper.getTimeString(start);
    }

    public String getEndTimeString() {
        return CalendarHelper.getTimeString(end);
    }

    public String getStartDateTimeString() {
        return CalendarHelper.getDateTimeString(start);
    }

    public String getEndDateTimeString() {
        return CalendarHelper.getDateTimeString(end);
    }

    /**************************************  Mutators ********************************************/

    public boolean updateStartDate(String dateString) {
        return CalendarHelper.updateDate(start, dateString);
    }

    public boolean updateStartTime(String timeString) {
        return CalendarHelper.updateTime(start, timeString);
    }

    public boolean updateStartDateTime(String dateTimeString) {
        return CalendarHelper.updateDateTime(start, dateTimeString);
    }

    public boolean updateEndDate(String dateString) {
        return CalendarHelper.updateDate(end, dateString);
    }

    public boolean updateEndTime(String timeString) {
        return CalendarHelper.updateTime(end, timeString);
    }

    public boolean updateEndDateTime(String dateTimeString) {
        return CalendarHelper.updateDateTime(end, dateTimeString);
    }

    public boolean updateStart(String calendarString) {
        return CalendarHelper.updateCalendar(start, calendarString);
    }
    
    public boolean updateEnd(String calendarString) {
        return CalendarHelper.updateCalendar(end, calendarString);
    }


    /*********************************** Overriding Methods ***********************************/

    public String toString(){
        return  getId() + "\n" 
                + getName() + "\n" 
                + getStartDateString() + "\n" 
                + getEndDateString() + "\n" 
                + getStartTimeString() + "\n" 
                + getEndTimeString();
    }

    public String toFormattedString(String dateString) throws ParseException {
        Calendar date = CalendarHelper.parseDate(dateString);

        String startTime = "00:00";
        String endTime = "23:59";

        CalendarHelper.updateTime(date, startTime);
        if (date.before(start)) {
            startTime = getStartTimeString();
        }

        CalendarHelper.updateTime(date, endTime);
        if (date.after(end)) {
            endTime = getEndTimeString();
        }

        return getName();
    }
    
    public String toFormattedString() throws ParseException {

        return getName();
    }
    
    public String getStartTimeStringOn(String dateString) {
        String timeString;
        if (this.getStartDateString().equals(dateString)) {
            timeString = this.getStartTimeString();
        }
        else {
            timeString = "00:00";
        }
        return timeString;
    }
    
    public String getEndTimeStringOn(String dateString) {
        String timeString;
        if (this.getEndDateString().equals(dateString)) {
            timeString = this.getEndTimeString();
        }
        else {
            timeString = "23:59";
        }
        return timeString;
    }
    
    public String getTimeStringOn(String dateString) {
        String timeString = "";
        timeString += getStartTimeStringOn(dateString);
        timeString += " to ";
        timeString += getEndTimeStringOn(dateString);
        
        return timeString;
    }
    
    

}
```
###### ./src/object/Item.java
``` java

package object;

import java.text.ParseException;
import java.util.Calendar;

import helper.CalendarHelper;

public abstract class Item implements Comparable<Item> {
    private String name;
    private String additionalInfo;
	private int id;
	private boolean done;
	private static int counter = 0;
    
    public Item(String name, String additionalInfo) {
        setName(name);
        setAdditionalInfo(additionalInfo);
        setId(counter++);
        setDone(false);
//        System.out.println(id + " " + name);			//for checking purposes
    }
    
    /**
     * Retrieves item name	
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets item name
     */
    public boolean setName(String name) {
        name = name.trim();
        if (name.isEmpty()) {
            return false;
        }
        else {
            this.name = name;
            return true;
        }
    }

    /**
     * Retrieves the additional info of an item
     */
    public String getAdditionalInfo() {
        return additionalInfo;
    }
    

    /**
     * Sets the additional info of an item
     */
    public void setAdditionalInfo(String additionalInfo) {
        this.additionalInfo = additionalInfo;
    }
    
    /**
     * Gets the Id of object
     */
    public int getId() {
    	return id;
    }
    
    /**
     * Sets the Id of object
     */
    public void setId(int counter) {
    	this.id = counter;
    }
    
    /**
     * Generates a number to set to object
     */
    public static int getCounter() {
    	return counter;
    }
    
    /**
     * Sets counter to set the Id of object
     */
    public static void setCounter(int count){
    	counter = count;
    }
    
    public boolean getDone() {
    	return done;
    }
    
    public void setDone(boolean check) {
    	done = check;
    }
    
    public abstract String toFormattedString() throws ParseException;
    
    public int compareTo(Item other) {
        if (this instanceof Event) {
            if (other instanceof Event) {
                return ((Event)this).getStartCalendar().compareTo(((Event)other).getStartCalendar());
            }
            else if (((Todo)other).hasDate()){
            	
            	//Testing to debug why Event compare to Todo return 0 fails.
            	//System.out.println("1. " + ((Event)this).getStartCalendar());
            	//System.out.println("2. " + ((Todo)other).getDeadline());
                return ((Event)this).getStartCalendar().compareTo(((Todo)other).getDeadline());
            }
            else {
                return -1;
            }
        }
        else if (((Todo)this).hasDate()) {
            if (other instanceof Event) {
                return ((Todo)this).getDeadline().compareTo(((Event)other).getStartCalendar());
            }
            else if (((Todo)other).hasDate()) {
                return ((Todo)this).getDeadline().compareTo(((Todo)other).getDeadline());
            }
            else {
                return -1;
            }
        }
        else {
            if (other instanceof Event) {
                return 1;
            }
            else if (((Todo)other).hasDate()) {
                return 1;
            }
            else {
                return Integer.valueOf(this.getId()).compareTo(Integer.valueOf(other.getId()));
            }
        }
    }
    
    public boolean equals(Object other) {
        return getId() == ((Item) other).getId();
    }
    
    public String getDisplayDateString() {
        String date;
        if (this instanceof Event) {
            date = ((Event)this).getStartDateString();
        }
        else {
            if (((Todo)this).hasDate()) {
                date = ((Todo)this).getDeadlineDateString();
            } else {
                date = CalendarHelper.getDateString(Calendar.getInstance());
            }
        }
        return date;
    }
    
    public abstract String getTimeStringOn(String dateString);
    
}
```
###### ./src/object/Todo.java
``` java

package object;

import helper.CalendarHelper;

import java.text.ParseException;
import java.util.Calendar;

/**
 * Assumption is that the time and date format goes as follow:
 * 1) date: dd mm yyyy
 * 2) time: hhmm
 * 
 */

public class Todo extends Item {

    private static final String DEFAULT_DATE = "01 Jan 0000";	// the earliest Date possible
    
	private Calendar deadline = null;
    private boolean hasDate = true;
    private boolean hasTime = true;


    /************************************ Constructor ***************************************/

    public Todo(String name) {
        this(name, "");
    }

    public Todo(String name, String additionalInfo) {
        this(name, additionalInfo, DEFAULT_DATE);
    }

    public Todo(String name, String additionalInfo, String deadlineDate) {
        this(name, additionalInfo, deadlineDate, "");
    }

    public Todo(String name, String additionalInfo, String deadlineDate, String deadlineTime) {
        super(name, additionalInfo);

        this.deadline = Calendar.getInstance();

        hasDate = CalendarHelper.updateDate(this.deadline, deadlineDate);
        hasTime = CalendarHelper.updateTime(this.deadline, deadlineTime);
        	
        if(deadlineDate.equals(DEFAULT_DATE)){
        	hasDate = false;
        }
    }

    /************************************ Accessors ***************************************/

    public Calendar getDeadline(){
        return deadline;
    }

    public String getDeadlineDateString(){
        return CalendarHelper.getDateString(deadline);
    }

    public String getDeadlineTimeString(){
        return CalendarHelper.getTimeString(deadline);
    }

    public String getDeadlineDateTimeString(){
        return CalendarHelper.getDateTimeString(deadline);
    }

    public boolean hasDate(){
        return hasDate;
    }

    public boolean hasTime(){
        return hasTime;
    }

    /*********************************  Mutators ********************************************/

    public boolean updateDeadlineDate(String dateString) {
        return CalendarHelper.updateDate(deadline, dateString);
    }

    public boolean updateDeadlineTime(String timeString) {
        return CalendarHelper.updateTime(deadline, timeString);
    }

    public boolean updateDeadlineDateTime(String dateTimeString) {
        return CalendarHelper.updateDateTime(deadline, dateTimeString);
    }
    
    public boolean updateDeadline(String calendarString) {
        return CalendarHelper.updateCalendar(deadline, calendarString);
    }

    /********************************** Process Dates ****************************************/

    /********************************* Process Time ******************************************/

    /******************************* Overriding Methods ***************************************/

    public String toString(){
        String allDetails = (getName() + "\n");

        if (hasDate) {
            allDetails = allDetails.concat(getDeadlineDateString());
        }
        else {
            allDetails = allDetails.concat("no date");
        }

        allDetails = allDetails.concat("\n");

        if (hasTime) {
            allDetails = allDetails.concat(getDeadlineTimeString());
        }
        else {
            allDetails = allDetails.concat("no time");
        }
                
        return allDetails;
    }

    public String toFormattedString(String dateString) throws ParseException {
        

        return getName();
    }
    
    public String toFormattedString() throws ParseException {
        
        return getName();
    }
    
    public String getTimeStringOn(String dateString) {
        if (hasDate()) {
            return getDeadlineTimeString();
        } else {
            return "";
        }
    }

}
```
###### ./src/project/EventComparator.java
``` java

package project;
import object.Event;
import java.util.*;

public class EventComparator implements Comparator<Event> {
	
	Calendar event1Start, event2Start, event1End, event2End;
	
	@Override
	public int compare(Event event1, Event event2) {
		extractDate(event1, event2);
		return compareStart();
	}
	
	private int compareStart() {
		if (event1Start.compareTo(event2Start) == 0){
			return compareEnd();
		} else {
			return event1Start.compareTo(event2Start);
		}
	}
	
	private int compareEnd() {
		return event1End.compareTo(event2End);
	}
	
	private void extractDate(Event event1, Event event2) {
		event1Start = event1.getStartCalendar();
		event2Start = event2.getStartCalendar();
		event1End = event1.getEndCalendar();
		event2End = event2.getEndCalendar();
	}
}
```
###### ./src/project/ProjectHandler.java
``` java

package project;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

import object.Event;
import storage.FileHandler;


public class ProjectHandler implements ProjectManager{

	private FileHandler project;
	// String in HashMap => Progress
	private HashMap<Integer, String> map;
	private ArrayList<Integer> projectBook = new ArrayList<Integer>();
		
	public ProjectHandler (){
		project = new FileHandler();
	}		
	
	/**
	 * Adds an existing Event by ID into Project ArrayList
	 */
	@Override
	public boolean addProjectEvent(Event event, String projectName) {
		assert(projectName != null); 	//checked by Projects first
		try {
			projectBook = viewProjectTimeline(projectName.toLowerCase());
			projectBook.add(event.getId());
			sortEvents();
			project.saveEditedProjectDetails(projectBook, map, projectName.toLowerCase());
			return true;
		} catch (Exception E) {
			return false;
		}
	}

	
	@Override
	public boolean deleteProjectEvent(int index, String projectName) {
		assert(projectName != null); 	//checked by Projects first
		viewProjectTimeline(projectName);
		if (index < projectBook.size()) {
			int id = projectBook.get(index);
			Event event = project.retrieveEventById(id);
			return deleteProjectEvent(event, projectName);
		} else {
			return false;
		}
	}
	
	
	@Override
	public boolean deleteProjectEvent(Event event, String projectName) {
		assert(projectName != null); 	//checked by Projects first
		viewProjectTimeline(projectName);
		int id = extractIdFromEvent(event);
		int index = 0;
		for (int savedId : projectBook) {
			if (savedId == id) {
				projectBook.remove(index);
				map.remove(id);
				sortEvents();
				project.saveEditedProjectDetails(projectBook, map, projectName.toLowerCase());
				return true;
			}
			index++;
		} return false;
	}

	public int extractIdFromEvent(Event event) {
		int id = event.getId();
		return id;
	}
	
	@Override
	public boolean editProjectName(String newProjectName, String oldProjectName) {
		ArrayList<Integer> newProject = viewProjectTimeline(oldProjectName);
		return project.saveEditedProjectDetails(newProject, map, newProjectName);
	}
	
	/**
	 * Edits an existing Event in the Project ArrayList by the ID
	 */
	
	@Override
	public Event editEvent(int arrayIndex, String projectName) {
		assert(projectName != null); 	//checked by Projects first
		viewProjectTimeline(projectName);
		if (0 <= arrayIndex && arrayIndex < projectBook.size()) {
    		int id = projectBook.get(arrayIndex);
    		Event event = project.retrieveEventById(id); 
    		return event;
		} else {
		    return null;
		}
	}
	
	@Override
	public ArrayList<Integer> viewProjectTimeline(String projectName) {
		
		projectBook = project.retrieveProjectTimeLine(projectName.toLowerCase());
		map = project.retrieveProjectProgress();
		return projectBook;
	}

	@Override
	public ArrayList<Event> viewEventProgressTimeline(String projectName) {
		
		ArrayList<Integer> arrayListOfId = viewProjectTimeline(projectName);
		ArrayList<Event> eventProgress = new ArrayList<Event>();
		
		for (int id : arrayListOfId) {
			Event event = project.retrieveEventById(id);
			String progressMessage = map.get(id);
			event.setAdditionalInfo(progressMessage);
			eventProgress.add(event);
		}
		return eventProgress;
	}
	
	@Override
	public ArrayList<Event> viewProjectTimelineInEvents(String projectName) {
		ArrayList<Event> viewTimeline = new ArrayList<Event>();
		ArrayList<Integer> arrayListOfId = viewProjectTimeline(projectName);
		
		for (int id : arrayListOfId) {
			Event event = project.retrieveEventById(id);
			viewTimeline.add(event);
		}
		
		return viewTimeline;
	}

	private void sortEvents() {
		ArrayList<Event> eventsToBeSorted = new ArrayList<Event>();
		ArrayList<Integer> newProjectBook = new ArrayList<Integer>();
		
		for (int id : projectBook) {
			Event event = project.retrieveEventById(id);
			eventsToBeSorted.add(event);
		}
		
		EventComparator eventComparator = new EventComparator();
		Collections.sort(eventsToBeSorted, eventComparator);
		
		for (Event event : eventsToBeSorted) {
			int id = extractIdFromEvent(event);
			newProjectBook.add(id);
		}
		projectBook = newProjectBook;
	}
	
	@Override
	public double progressBar(String projectName) {
		assert(projectName != null); 	//checked by Projects first
		ArrayList<Integer> projectIdTimeline = viewProjectTimeline(projectName);

		int totalEvents = projectIdTimeline.size();
		
		if (totalEvents == 0) return 0;
		int eventsDone = 0;
		double percentageDone = 0;
		
		for (int id : projectIdTimeline) {
			Event event = project.retrieveEventById(id);
			if (event.getDone()) {
				eventsDone++;
			}
		}
		
		percentageDone = 100.0*((double)eventsDone/(double)totalEvents);

        DecimalFormat df = new DecimalFormat("#.##");      
        percentageDone = Double.valueOf(df.format(percentageDone));
		
		return percentageDone;
	}
	
	@Override
	public boolean addProgressMessage(int index, String progressMessage, String projectName) {
		assert(projectName != null); 	//checked by Projects first
		viewProjectTimeline(projectName);
        
        if (0 <= index && index < projectBook.size()) {
            int id = projectBook.get(index);
            map.put(id, progressMessage);
            return project.saveEditedProjectDetails(projectBook, map, projectName);
        } else {
            return false;
        }
	}
	
	@Override
	public boolean deleteProgressMessage(int index, String projectName) {
		assert(projectName != null); 	//checked by Projects first
	    viewProjectTimeline(projectName);
        if (0 <= index && index < projectBook.size()) {
            int id = projectBook.get(index);
            //System.out.println(map.remove(id));
            if (map.remove(id).equals("")) {
                return false;
            }
            return project.saveEditedProjectDetails(projectBook, map, projectName);
        
        } else {
            return false;
        }
	}
	
	
	@Override
	public boolean editProgressMessage(int index, String newProgressMessage, String projectName) {
		assert(projectName != null); 	//checked by Projects first
        if (deleteProgressMessage(index, projectName)) {
            return addProgressMessage(index, newProgressMessage, projectName);
        } else {
            return false;
        }
	}

    public boolean findItem(int id, String projectName) {
        projectBook = viewProjectTimeline(projectName.toLowerCase());
        return projectBook.contains(id);
    }
}
```
###### ./src/project/ProjectManager.java
``` java
package project;
import java.util.ArrayList;

import object.Event;


public interface ProjectManager {
	
	public boolean addProjectEvent (Event event, String projectName);
	public boolean deleteProjectEvent(Event event, String projectName);
	public boolean editProjectName(String newProjectName, String oldProjectName);
	public ArrayList<Integer> viewProjectTimeline(String name);
	public ArrayList<Event> viewEventProgressTimeline(String projectName);
	public double progressBar(String projectName);
	public ArrayList<Event> viewProjectTimelineInEvents(String projectName);
	public boolean deleteProjectEvent(int index, String projectName);
	public Event editEvent(int arrayIndex, String projectName);
	public boolean addProgressMessage(int index, String progressMessage, String projectName);
	public boolean deleteProgressMessage(int index, String projectName);
	public boolean editProgressMessage(int index, String newProgressMessage, String projectName);
	}
```
###### ./src/project/Projects.java
``` java
package project;

import java.util.ArrayList;

import storage.FileHandler;
import object.Event;
import object.Item;

public class Projects {

	private static final int INVALID_PROGRESS_PERCENTAGE = -1;
	private FileHandler project;
	private ProjectHandler pHandler;
	private ArrayList<String> projectList; 
	
	public Projects (){
		project = new FileHandler();
		projectList = project.getListOfExistingProject();
		pHandler = new ProjectHandler();
	}
	
	/**
	 * Adds a new Project into the ArrayList
	 * @param projectName is the name of the Project to be created
	 * @return returns true once Project is created, else return false
	 */
	public boolean createProject(String projectName) {
		return project.createNewProject(projectName.toLowerCase().trim());
	}
	
	/**
	 * Deletes an existing Project from the ArrayList
	 * @param projectName is the name of the Project to be deleted
	 * @return returns true once Project is deleted, else return false
	 */
	public boolean deleteProject(String projectName) {
		return project.deleteProject(projectName.toLowerCase());
	}
	
	/**
	 * Edits an existing Project from the ArrayList
	 * @param newProjectName is the name of the Project that is edited to
	 * @param oldProjectName is the name of the Project that is being edited
	 * @return returns true once Project is edited, else return false.
	 */
	public boolean editProjectName(String newProjectName, String oldProjectName) {
		/*if (createProject(newProjectName) && pHandler.editProjectName(newProjectName.toLowerCase(), oldProjectName.toLowerCase())
				&& deleteProject(oldProjectName)) {
				return true;
		}
		return false;
		*/
		ArrayList<String> checkExistingProject = new ArrayList<String>();
		checkExistingProject = listExistingProjects();
		if (newProjectName.equals(oldProjectName) || !(checkExistingProject.contains(oldProjectName))) {
			return false;
		}
		
		if (createProject(newProjectName)) {
			if (pHandler.editProjectName(newProjectName.toLowerCase(), oldProjectName.toLowerCase())) {
				if (deleteProject(oldProjectName)) {
					return true;
				} else {
					deleteProject(newProjectName);
				}
			} else {
				deleteProject(newProjectName);
			}
		} 
		return false;
			
	}
	
	/**
	 * Views an ArrayList of existing Projects
	 * @return returns an ArrayList of Strings where each String is the name of existing Projects
	 */
	public ArrayList<String> listExistingProjects() {
		return project.getListOfExistingProject();
	}
	
	/**
	 * Adds an existing Event into a Project by the Project Name
	 * @param event is the Event that is being added into the Project
	 * @param projectName is the Project that the Event is added to
	 * @return returns true once Event is added into Project, else return false
	 */
	public boolean addProjectEvent(Event event, String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return false;
		} else {
		return pHandler.addProjectEvent(event, projectName);
		}
	}
	
	/**
	 * Adds an existing Event into a Project by the Project Index
	 * @param event is the Event that is being added into the Project
	 * @param index is the index of the Project that the Event is added to
	 * @return returns true once Event is added into Project, else return false
	 */
	public boolean addProjectEvent(Event event, int index) {
		updateProjectList();
		if (index < projectList.size()) {
			String projectName = projectList.get(index);
			return addProjectEvent(event, projectName);
		} else {
			return false;
		}
	}
	
	/**
	 * Removes an Event added into a Project by Project Name and Event
	 * @param event is the Event that is to be deleted from a Project
	 * @param projectName is the name of the Project that is to be deleted from
	 * @return returns true once the Event is deleted from the Project, else return false
	 */
	public boolean deleteProjectEvent(Event event, String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return false;
		} else {
		return pHandler.deleteProjectEvent(event, projectName);
		}
	}
	
	/**
	 * Removes an Event added into a Project by Project Index and Event
	 * @param event is the Event that is to be deletd from a Project
	 * @param index is the index of the Project that the Event is to be deleted from
	 * @return returns true once the Event is deleted from the Project, else return false
	 */
	public boolean deleteProjectEvent(Event event, int index) {
		updateProjectList();
		if (index < projectList.size()) {
			String projectName = projectList.get(index);
			return deleteProjectEvent(event, projectName);
		} else {
			return false;
		}
	}

	/**
	 * Updates Project List to its latest copy
	 */
	public void updateProjectList() {
		projectList = listExistingProjects();
	}
	
	/**
	 * Removes an Event added into a Project by Project Name and Event Index
	 * @param eventArrayListIndex is the index of the ArrayList that the Event is in
	 * @param projectName is the name of the Project that the Event is being deleted from
	 * @return returns true once Event is deleted from the Project, else return false
	 */
	public boolean deleteProjectEvent(int eventArrayListIndex, String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return false;
		} else {
		return pHandler.deleteProjectEvent(eventArrayListIndex, projectName);
		}
	}
	
	/**
	 * Extracts the Event to be edited by Project Name and Event Index
	 * @param arrayIndex is the index of the ArrayList that holds the Event to be edited
	 * @param projectName is the name of the Project that the Event is in
	 * @return returns an Event that is to be edited, else return null 
	 */
	public Event editEvent(int arrayIndex, String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return null;
		} else {
		return pHandler.editEvent(arrayIndex, projectName);
		}
	}
	
	/**
	 * View an ArrayList of Event IDs by Project Name
	 * @param projectName is the name of the Project that is being viewed
	 * @return returns an ArrayList of Integers if Project exists, else return null
	 */
	public ArrayList<Integer> viewProjectTimeline(String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return null;
		} else {
		return pHandler.viewProjectTimeline(projectName);
		}
	}
	
	/**
	 * View an ArrayList of Event IDs by Project Index
	 * @param index is the Index of the Project that is being viewed
	 * @return returns an ArrayList of Integers if Project exists, else return null
	 */
	public ArrayList<Integer> viewProjectTimeline(int index) {
		updateProjectList();
		if (index < projectList.size()) {
			String projectName = projectList.get(index);
			return viewProjectTimeline(projectName);
		} else {
			return null;
		}
	}
	
	/**
	 * View an ArrayList of Events by Project Name
	 * @param projectName is the name of the Project that is being viewed
	 * @return returns an ArrayList of Events if Project exists, else return null
	 */
	public ArrayList<Event> viewProjectTimelineInEvents(String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return null;
		} else {
		return pHandler.viewProjectTimelineInEvents(projectName);
		}
	}
	
	/**
	 * View an ArrayList of Events by Project Index
	 * @param index is the Index of the Project that is being viewed
	 * @return returns an ArrayList of Events if Project exists, else return null
	 */
	public ArrayList<Event> viewProjectTimelineInEvents(int index) {
		updateProjectList();
		if (index < projectList.size()) {
			String projectName = projectList.get(index);
			return viewProjectTimelineInEvents(projectName);
		} else {
			return null;
		}
	}
	
	/**
	 * Searches for a Project in an ArrayList of Projects
	 * @param name is part of the name of the Project that is searched
	 * @return returns an ArrayLst of Strings that contains Projects that contain the String name. 
	 */
	public ArrayList<String> searchProjects (String name) {
		projectList = project.getListOfExistingProject();
		ArrayList<String> searchedNames = new ArrayList<String>();
		for (String projectName : projectList) {
			if (projectName.contains(name)) {	
				searchedNames.add(projectName);
			}
		}
		return searchedNames;
	}
	
	/**
	 * Calculates the percentage of completed Events in a Project
	 * @param projectName is the Project name of the Project
	 * @return returns a double value of the percentage of checked Events, else return negative value
	 */
	public double progressBar(String projectName) {
		if (checkIfProjectExists(projectName)) {
			return pHandler.progressBar(projectName.toLowerCase());
		}
		return INVALID_PROGRESS_PERCENTAGE;
	}
	
	/**
	 * Adds a message into a HashMap of a Project
	 * @param index is the index of the Event in a Project
	 * @param projectName is the name of the Project that the message is being added to
	 * @param progressMessage is the message that is being added to an Event
	 * @return returns true once message is added to the Event, else return false
	 */
	public boolean addProgressMessage(int index, String projectName, String progressMessage) {
		if (checkIfProjectExists(projectName)) {
			return pHandler.addProgressMessage(index, progressMessage, projectName.toLowerCase());
		} 
		return false;
	}
	
	/**
	 * Deletes a message from a HashMap of a Project
	 * @param index is the index of the Event in a Project
	 * @param projectName is the name of the Project that the message is being deleted from
	 * @return returns true once message is deleted from the Event, else return false
	 */
	public boolean deleteProgressMessage(int index, String projectName) {
		if (checkIfProjectExists(projectName)) {
			return pHandler.deleteProgressMessage(index, projectName.toLowerCase());
		} 
		return false;
	}
	
	/**
	 * Edits a message in a HashMap of a Project
	 * @param index is the index of the Event in a Project
	 * @param newProressMessage is the message that is being updated to 
	 * @param projectNmae is the name of the Project that the new message is being added to
	 * @return returns true once the message is edited in the Event, else return false
	 */
	public boolean editProgressMessage(int index, String newProgressMessage, String projectName) {
		if (checkIfProjectExists(projectName)) {
			return pHandler.editProgressMessage(index, newProgressMessage, projectName.toLowerCase());
		} 
		return false;
	}

	/**
	 * Checks if Project exists in the ArrayList
	 * @param projectName is the name of the Project that is being checked
	 * @return returns true if the searched Project exists, else return false
	 */
	public boolean checkIfProjectExists(String projectName) {
		return listExistingProjects().contains(projectName.toLowerCase());
	}
	
	/**
	 * Views by Project Name, a Project Timeline with the Progress Message each Event holds
	 * @param projectName is the name of the Project that is being viewed
	 * @return returns an ArrayList of Events that holds the Events and its Progress Message
	 */
	public ArrayList<Event> viewEventProgressTimeline(String projectName) {
		if (!checkIfProjectExists(projectName)) {
			return null;
		} else {
		return pHandler.viewEventProgressTimeline(projectName.toLowerCase());
		}
	}
	
	/**
	 * Views by Project Index, a Project Timeline with the Progress Message each Event holds
	 * @param index is the index of the Project that is being viewed
	 * @return returns an ArrayList of Events that holds the Events and its Progress Message
	 */
	public ArrayList<Event> viewEventProgressTimeline(int index) {
		updateProjectList();
		if (index < projectList.size()) {
			String projectName = projectList.get(index);
			return viewEventProgressTimeline(projectName);
		} else {
			return null;
		}
	}
	
	/**
	 * Searches for an Event in a Project
	 * @param item is the item that is to be found 
	 * @return returns a String that is the Project the item is found in, else return null
	 */
	public String searchItem(Item item) {
	    int id = item.getId();
	    
	    updateProjectList();
	    
	    for (String project : projectList) {
	        if (pHandler.findItem(id, project)) {
	            return project;
	        }
	    }
	    
	    return null;
	}
}
```
###### ./src/test/object/TestEvent.java
``` java
package test.object;

import org.junit.Test;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import static org.junit.Assert.*;

import java.util.Calendar;
import java.text.SimpleDateFormat;

import object.Event;
import object.Item;
import storage.FileHandler;

public class TestEvent {

	private static final String EXPECTED_TO_STRING = "2\nEventName3\n21 Oct 2015\n30 Oct 2015\n17:00\n02:00";

	private static final String MESSAGE_TEAR_DOWN = "Test Files used in Event Testing Cleared";

	private static final String MESSAGE_SET_UP = "Files Cleared for Event Class Testing";

	private static final String DATE_FORMAT = "dd MMM yyyy HH:mm";

	private static final String ADD_INFO_BLANK = "";

	private static final String EVENT3_END_TIME = "02:00";

	private static final String EVENT2_END_TIME = "23:00";

	private static final String EVENT1_END_TIME = "21:00";

	private static final String EVENT3_START_TIME = "17:00";

	private static final String EVENT2_START_TIME = "19:00";

	private static final String EVENT1_START_TIME = "10:00";

	private static final String EVENT3_END_DATE = "30 Oct 2015";

	private static final String EVENT2_END_DATE = "31 Oct 2015";

	private static final String EVENT1_END_DATE = "26 Oct 2015";

	private static final String EVENT2_START_DATE = "21 Oct 2015";

	private static final String EVENT1_START_DATE = "25 Oct 2015";

	private static final String EVENT_NAME3 = "EventName3";

	private static final String EVENT_NAME2 = "EventName2";

	private static final String EVENT_NAME1 = "EventName1";

	protected static FileHandler clear;
	
	// Make sure dates are in DD MMM YYY format 
	private Event event1 = new Event(EVENT_NAME1, EVENT1_START_DATE, EVENT1_END_DATE, EVENT1_START_TIME, EVENT1_END_TIME, ADD_INFO_BLANK);
	private Event event2 = new Event(EVENT_NAME2, EVENT2_START_DATE, EVENT2_END_DATE, EVENT2_START_TIME, EVENT2_END_TIME, ADD_INFO_BLANK);
	private Event event3 = new Event(EVENT_NAME3, EVENT2_START_DATE, EVENT3_END_DATE, EVENT3_START_TIME, EVENT3_END_TIME, ADD_INFO_BLANK);
	
	// Use SimpleDateFormat because of the millisecond difference when comparing the Calendar Objects
	private SimpleDateFormat testingFormat = new SimpleDateFormat (DATE_FORMAT);
	
	@Before
	public void beforeTest() {
	    Item.setCounter(0);
	}
	
	@BeforeClass
	public static void setUpBeforeTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_SET_UP);
	}
	
	@AfterClass
	public static void tearDownAfterTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_TEAR_DOWN);
	}
	
	@Test
	public void testUpdateAndGetMethods() throws AssertionError {
		try {
			assertTrue("Failed updateStart()", event1.updateStart("03 May 1995 07:00"));
			Calendar retrievedStartCalendar = event1.getStartCalendar();
			// Use SimpleDateFormat because of the millisecond difference when comparing the Calendar Objects
			assertEquals("Failed getStartCalendar()", "03 May 1995 07:00", testingFormat.format(retrievedStartCalendar.getTime()));
			
			assertTrue("Failed updateEnd()", event2.updateEnd("09 Nov 1993 19:00"));
			Calendar retrievedEndCalendar = event2.getEndCalendar();
			//Use SimpleDateFormat because of the millisecond difference when comparing the Calendar Objects
			assertEquals("Failed getEndCalendar()", "09 Nov 1993 19:00", testingFormat.format(retrievedEndCalendar.getTime()));
			
			assertTrue("Failed updateStartDate()", event1.updateStartDate(EVENT1_END_DATE));
			String retrievedStartDate = event1.getStartDateString();
			assertEquals("Failed getStartDateString()", EVENT1_END_DATE, retrievedStartDate);
			
			assertTrue("Failed updateEndDate()", event1.updateEndDate("29 Oct 2015"));
			String retrievedEndDate = event1.getEndDateString();
			assertEquals("Failed getEndDateString()", "29 Oct 2015", retrievedEndDate);
			
			assertTrue("Failed updateStartTime()", event2.updateStartTime("16:00"));
			String retrievedStartTime = event2.getStartTimeString();
			assertEquals("Failed getStartTimeString()", "16:00", retrievedStartTime);
			
			assertTrue("Failed updateEndTime()", event2.updateEndTime("22:00"));
			String retrievedEndTime = event2.getEndTimeString();
			assertEquals("Failed getEndTimeString()", "22:00", retrievedEndTime);
			
			assertTrue("Failed updateStartDateTime()", event2.updateStartDateTime("01 Jan 2001 11:00"));
			String retrievedStartDateTime = event2.getStartDateTimeString();
			assertEquals("Failed getStartDateTimeString()", "01 Jan 2001 11:00", retrievedStartDateTime);
			
			assertTrue("Failed updateEndDateTime()", event2.updateEndDateTime("31 Dec 2001 23:59"));
			String retrievedEndDateTime = event2.getEndDateTimeString();
			assertEquals("Failed getEndDateTimeString()", "31 Dec 2001 23:59", retrievedEndDateTime);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}	
	
	@Test
	public void testToString() throws AssertionError {
		try {
			String isString = event3.toString();
			assertEquals("Failed toString()",  EXPECTED_TO_STRING, isString);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testFormattedStringWithParameters() throws AssertionError, Exception {
		try {
			String formattedWithParameters = event3.toFormattedString("09 Nov 1993");
			assertEquals("Fail toFormattedString(para)", EVENT_NAME3, formattedWithParameters);
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testFormattedString() throws AssertionError, Exception {
		try {
			String formatted = event3.toFormattedString();
			assertEquals("Fail toFormattedString", EVENT_NAME3, formatted);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}

}
```
###### ./src/test/object/TestItem.java
``` java
package test.object;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import object.Event;
import object.Item;
import object.Todo;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import storage.FileHandler;



public class TestItem {

	private static final String MESSAGE_TEAR_DOWN = "Test Files used in Item Testing Cleared";
	private static final String MESSAGE_SET_UP = "Files Cleared for Item Testing";
	//Instantiate using Todo because Item is an Abstract Class and cannot be instantiated
	protected static Item item; 
	protected static FileHandler clear;
	
	private static Event event1;
	private static Event event2;
	private static Todo todo1;
	private static Todo todo2;
	private static Todo todo3;
	private static Item item2;
	
	@BeforeClass
	public static void setUpBeforeTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_SET_UP);
	}
	
	@AfterClass
	public static void tearDownAfterTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		Item.setCounter(0);  
		System.out.println(MESSAGE_TEAR_DOWN);
	}
	
	@BeforeClass
	public static void beforeTestClass(){
		
		Item.setCounter(0);  	//reset count
		item = new Todo("testingName", "testingAddInfo");
		event1 = new Event("EventName1", "25 Oct 2015", "10:00", "21:00", "");
		event2 = new Event("EventName2", "21 Oct 2015", "19:00", "23:00", "");
		todo1 = new Todo("Todo1", "", "09 Nov 1993", "16:00");
		todo2 = new Todo("Todo2", "", "03 May 1995", "11:00");
		todo3 = new Todo("Todo3", "", "25 Oct 2015", "10:00");
		item2 = new Todo("testingName2", "testingAddInfo2");
	}
		
	@Test
	public void testGetAndSetMethods() throws AssertionError {
		
		try {
	
			String gottenName = item.getName();
	
			assertEquals("Fail getName() and setName()", "testingName", gottenName);
			
			String gottenAddInfo = item.getAdditionalInfo();
			assertEquals("Fail getAdditionalInfo() and setAdditionalInfo()", "testingAddInfo", gottenAddInfo);
			
			int gottenId = item.getId();
			assertEquals("Fail getId() and setId()", 0, gottenId);
			
			boolean gottenDone = item.getDone();
			assertFalse("Fail getDone and setDone()", gottenDone);
		} catch (AssertionError AE) {
			System.out.println (AE.getMessage());
			throw AE;
		}
		
	}
	
	
	@Test
	public void testEventCompareTo() throws AssertionError {
		
		try {
			int eventToEventReturnPos1 = event1.compareTo(event2);
			int eventToEventReturn0 = event1.compareTo(event1);
			int eventToEventReturnNeg1 = event2.compareTo(event1);
			assertEquals("Fail Event to Event Return 1 (A later than B)", 1, eventToEventReturnPos1);
			assertEquals("Fail Event to Event Return 0 (A same as B)", 0, eventToEventReturn0);
			assertEquals("Fail Event to Event Return -1 (A earlier than B)", -1, eventToEventReturnNeg1);
			
			int eventToTodoReturnNeg1 = todo2.compareTo(event1);
			int eventToTodoReturnPos1 = event1.compareTo(todo2);

			assertEquals("Fail Event to Todo Return 1 (A later than B)", 1, eventToTodoReturnPos1);

			assertEquals("Fail Event to Todo Return -1 (A earlier than B)", -1, eventToTodoReturnNeg1);
			
			int eventToItemReturnNeg1 = event1.compareTo(item2);
			assertEquals("Fail Event to Item Return -1 (A earlier than B)", -1, eventToItemReturnNeg1);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testTodoCompareTo() throws AssertionError {
		
		try {
			int TodoToEventReturnNeg1 = todo1.compareTo(event2);
			int TodoToEventReturnPos1 = event2.compareTo(todo1);
			assertEquals("Fail Todo to Event Return 1 (A later than B)", 1, TodoToEventReturnPos1);
			assertEquals("Fail Todo to Event Return -1 (A earlier than B)", -1, TodoToEventReturnNeg1);
			
			int TodoToTodoReturnNeg1 = todo1.compareTo(todo2);
			int TodoToTodoReturnPos1 = todo2.compareTo(todo1);
			int TodoToTodoReturn0 = todo3.compareTo(todo3);
			assertEquals("Fail Todo to Todo Return 1 (A later than B)", 1, TodoToTodoReturnPos1);
			assertEquals("Fail Todo to Todo Return 0 (A same as B)", 0, TodoToTodoReturn0);
			assertEquals("Fail Todo to Todo Return -1 (A earlier than B)", -1, TodoToTodoReturnNeg1);
			
			int TodoToItemReturnNeg1 = todo1.compareTo(item2);
			assertEquals("Fail Todo to Item Return -1 (A earlier than B)", -1, TodoToItemReturnNeg1);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
		
	}
	
	@Test
	public void testItemCompareTo() throws AssertionError {
		
		try {
			int ItemToItemReturnNeg1 = item.compareTo(item2);
			int ItemToItemReturn0 = item2.compareTo(item2);
			int ItemToItemReturnPos1 = item2.compareTo(item);
			assertEquals("Fail Item to Item Return 1 (A later than B)", 1, ItemToItemReturnPos1);
			assertEquals("Fail Item to Item Return 0 (A same as B)", 0, ItemToItemReturn0);
			assertEquals("Fail Item to Item Return -1 (A earlier than B)", -1, ItemToItemReturnNeg1);
			
			int ItemToEventReturnPos1 = item.compareTo(event1);

			assertEquals("Fail Item to Event Return 1 (A later than B)", 1, ItemToEventReturnPos1);
			
			int ItemToTodoReturnPos1 = item.compareTo(todo1);
			
			assertEquals("Fail Item to Todo Return 1 (A earlier than B)", 1, ItemToTodoReturnPos1);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
		
	}
	
	@Test
	public void testEquals() throws AssertionError {
		
		try {
			assertTrue("Fail item == item", item.equals(item));
			assertFalse("Fail item != item2", item.equals(item2));
		} catch (AssertionError AE) {
			System.out.println (AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testCounter() throws AssertionError {
		try {
			assertEquals("Fail counter", 3, todo1.getId());
		} catch (AssertionError AE) {
			System.out.println (AE.getMessage());
			throw AE;
		}
	}

}
```
###### ./src/test/object/TestTodo.java
``` java
package test.object;

import org.junit.Test;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import static org.junit.Assert.*;

import java.text.SimpleDateFormat;

import object.Item;
import object.Todo;
import storage.FileHandler;

public class TestTodo {
	
	private static final String MESSAGE_TEAR_DOWN = "Test Files used in Todo Testing Cleared";

	private static final String MESSAGE_SET_UP = "Files Cleared for Todo Testing";

	protected static FileHandler clear;
	
	private static Todo todo1;
	private static Todo todo2;
	private static Todo todo3;
	private static Todo todo4;
	private static Todo todo5;
	private static Todo todo6;
	
	private SimpleDateFormat testingFormat = new SimpleDateFormat ("dd MMM yyyy HH:mm");

	@BeforeClass
	public static void setUpBeforeTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_SET_UP);
	
		Item.setCounter(0);
		todo1 = new Todo("Todo1");
		todo2 = new Todo("Todo2", "");
		todo3 = new Todo("Todo3", "", "09 Nov 1993");
		todo4 = new Todo("Todo4", "", "03 May 1995", "16:00");
		todo5 = new Todo("Todo5", "");
		todo6 = new Todo("Todo6", "", "31 Oct 2015", "14:52");
	}
	
	@AfterClass
	public static void tearDownAfterTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		Item.setCounter(0);
		System.out.println(MESSAGE_TEAR_DOWN);
	}
	
	@Test
	public void testUpdateGetAndHas() throws AssertionError {
		try {
			assertTrue("Failed hasDate()", todo3.hasDate());
			assertFalse("Failed (Todo has no date) hasDate()", todo1.hasDate());
			assertTrue("Failed hasTime()", todo4.hasTime());
			assertFalse("Failed (Todo has no time) hasTime()", todo2.hasTime());
			
			String deadlineRetrieved = testingFormat.format(todo4.getDeadline().getTime());
			assertEquals("Failed getDeadline()", "03 May 1995 16:00", deadlineRetrieved);
			
			assertTrue("Failed updateDeadlineDate()", todo3.updateDeadlineDate("26 Oct 2015"));
			String retrievedDeadlineDate = todo3.getDeadlineDateString();
			assertEquals("Failed getDeadlineDateString()", "26 Oct 2015", retrievedDeadlineDate);
			
			assertTrue("Failed updateDeadlineTime()", todo4.updateDeadlineTime("17:00"));
			String retrievedDeadlineTime = todo4.getDeadlineTimeString();
			assertEquals("Failed getDeadlineTimeString()", "17:00", retrievedDeadlineTime);
			
			assertTrue("Failed updateDeadlineDateTime()", todo4.updateDeadlineDateTime("24 Oct 2015 22:00"));
			String retrievedDeadlineDateTime = todo4.getDeadlineDateTimeString();
			assertEquals("Failed getDeadlineDateTimeString()", "24 Oct 2015 22:00", retrievedDeadlineDateTime);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testToString() throws AssertionError {
		try {
			assertEquals("Failed toString() hasDatehasTime", "Todo4\n03 May 1995\n16:00", todo4.toString());
			assertEquals("Failed toString() hasNoDatehasNoTime", "Todo2\nno date\nno time", todo2.toString());		
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testFormattedStringWithParameters() throws AssertionError, Exception {
		try {
			assertEquals("Failed toFormattedStringWithPara (hasDatehasTime)", "Todo6", todo6.toFormattedString("25 Oct 2015"));
			assertEquals("Failed toFormattedStringWithPara (hasNoDatehasNoTime)", "Todo5", todo5.toFormattedString("25 Oct 2015"));
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testFormattedString() throws AssertionError, Exception {
		try {
			assertEquals("Failed toFormattedString (hasDatehasTime)", "Todo6", todo6.toFormattedString());
			assertEquals("Failed toFormattedString (hasNoDatehasNoTime)", "Todo5", todo5.toFormattedString());
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
}
```
###### ./src/test/project/TestProject.java
``` java
package test.project;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import object.Event;
import object.Item;
import project.Projects;
import storage.FileHandler;

public class TestProject {

	private static final String OLD_PROGRESS_MESSAGE = "Progress message here";
	private static final String NEW_PROGRESS_MESSAGE = "this is new";
	private static final String PROJECT_NAME_PROJECT = "Project";
	private static final String NON_EXISTENT_PROJECT = "nonexistent";
	private static final String PROJECT_NAME_HELLOWORLD = "helloWorld";
	private static final String PROJECT_NAME_HELLOALL = "helloAll";
	private static final String PROJECT_NAME_288_CHARACTERS = "welovedamith"
			+ "welovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamith"
			+ "welovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamith"
			+ "welovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamithwelovedamith";
	private static final String MESSAGE_TEAR_DOWN = "Test Files used in Project Testing Cleared";
	private static final String MESSAGE_SET_UP = "Files Cleared for Project Class Testing";
	protected static FileHandler clear;
	private Projects project;
	
	// Make sure dates are in DD MMM YYY format 
	private Event event1;
	private Event event2;
	private Event event3;
	
	@Before
	public void setUpBeforeTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_SET_UP);
		
		Item.setCounter(0);
	    event1 = new Event("EventName1", "25 Oct 2015", "26 Oct 2015", "10:00", "21:00", "");
	    event2 = new Event("EventName2", "21 Oct 2015", "31 Oct 2015", "19:00", "23:00", "");
	    event3 = new Event("EventName3", "21 Oct 2015", "30 Oct 2015", "17:00", "02:00", "");
	    project = new Projects();
	    
	    clear.saveNewEventHandler(event1);
	    clear.saveNewEventHandler(event2);
	    clear.saveNewEventHandler(event3);
	}
	
	@After
	public void tearDownAfterTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_TEAR_DOWN);
	}
	
	@Test
	public void testCreateDeleteEditProject() throws AssertionError {
		try {
			assertTrue("Failed to create project", project.createProject("cS2103t"));
			assertTrue("Failed to create project beginning with space", project.createProject("       cs2101"));
			
			assertFalse("Successfully created project with symbols", project.createProject("A'\\/;*^<>|?"));
			//Parser handles create null project and FileProjHandler handles "" as exception
			assertFalse("Successfully created project with no project name", project.createProject(""));
			assertFalse("Successfully created project with too long a name", project.createProject(PROJECT_NAME_288_CHARACTERS));
			
			//delete
			assertTrue("Failed to delete project", project.deleteProject("cS2103t"));
			
			assertFalse("Successfully deleted a non-existent project", project.deleteProject("nonexistent"));
			
			//edit
			assertTrue("Failed to edit project name", project.editProjectName("cs2103T", "cs2101"));
			
			assertFalse("Successfully edited a non-existent project name", project.editProjectName("ee2020", "ma1506"));
			assertFalse("Successfully edited an invalid new project name", project.editProjectName("|'\\/?*:><^", "cs2103T"));
			assertFalse("Successfully renamed a project with same project name", project.editProjectName("cs2103T", "cs2103T"));
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testlistExistingProjects() throws AssertionError {
		try {
			
			String[] strArray = new String[]{};
			assertArrayEquals("Failed to list empty existing projects", strArray, project.listExistingProjects().toArray());
			
			project.createProject(PROJECT_NAME_HELLOALL);
			project.createProject(PROJECT_NAME_HELLOWORLD);
			String[] strArray2 = new String[]{"helloall", "helloworld"};
			
			assertArrayEquals("Failed to list existing projects", strArray2, project.listExistingProjects().toArray());	
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}

	@Test
	public void testAddViewEditDeleteProjectTimeline() throws AssertionError {
		try {
			
			
			project.createProject(PROJECT_NAME_HELLOALL);
			project.createProject(PROJECT_NAME_HELLOWORLD);
			
			//Add
			assertTrue("Failed to add event to project by index", project.addProjectEvent(event1, 0));
			assertFalse("Successfully added even into non-existent project by index", project.addProjectEvent(event3, 3));
			assertTrue("Failed to add event to project by name", project.addProjectEvent(event2, "helloall"));
			assertFalse("Successfully added even into non-existent project by projectname", project.addProjectEvent(event3, "projnotexist"));
			
			//View
			Integer[] intArray = new Integer[]{1, 0}; //Sorted by timing
			assertArrayEquals("Failed to view project timeline by name", intArray, project.viewProjectTimeline("helloall").toArray());
			assertNull("Successfully view non-existent project's timeline by name", project.viewProjectTimeline(NON_EXISTENT_PROJECT));
			assertArrayEquals("Failed to view project timeline by index", intArray, project.viewProjectTimeline(0).toArray());
			assertNull("Successfully view non-existent project's timeline by index", project.viewProjectTimeline(3));
			
			Event[] eventArray = new Event[]{event2, event1}; //Sorted too!
			assertArrayEquals("Failed to view project event timeline by name", eventArray, project.viewProjectTimelineInEvents(PROJECT_NAME_HELLOALL).toArray());
			assertNull("Successfully viewed non-existent project event timeline by name", project.viewProjectTimelineInEvents(NON_EXISTENT_PROJECT));
			assertArrayEquals("Failed to view project event timeline by index", eventArray, project.viewProjectTimelineInEvents(0).toArray());
			assertNull("Successfully viewed non-existent project event timeline by index", project.viewProjectTimelineInEvents(3));
			
			//Pass to-be-edited Event to Parser to call editing in Event Class.
			assertEquals("Failed to edit Event", event2, project.editEvent(0, PROJECT_NAME_HELLOALL));
			assertNull("Successfully edited event in non-existent project", project.editEvent(0, NON_EXISTENT_PROJECT));
			
			//Delete
			assertTrue("Failed to delete Event by event, projectname", project.deleteProjectEvent(event1, PROJECT_NAME_HELLOALL));
			assertFalse("Successfully deleted event in non-existent project (event, projectname)", project.deleteProjectEvent(event2, NON_EXISTENT_PROJECT));
			assertFalse("Successfully deleted non-existent Event by event, projectname", project.deleteProjectEvent(event3, PROJECT_NAME_HELLOALL));
			
			assertTrue("Failed to delete Event by event, index", project.deleteProjectEvent(event2, 0));
			assertFalse("Successfully deleted event in non-existent project (event, index)", project.deleteProjectEvent(event2, 3));
			assertFalse("Successfully deleted non-existent Event by event, index", project.deleteProjectEvent(event3, 0));
			
			project.addProjectEvent(event3, "helloworld");
			assertTrue("Failed to delete Event by eventArrayListindex, projectname", project.deleteProjectEvent(0, "helloworld"));
			assertFalse("Successfully deleted event in non-existent project (eventALindex, projectname)", project.deleteProjectEvent(0, NON_EXISTENT_PROJECT));
			assertFalse("Successfully deleted non-existent Event by eventArrayListindex, projectname", project.deleteProjectEvent(1, "helloworld"));		
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testSearch() throws AssertionError{
		try {
			ArrayList<String> searchedNames = new ArrayList<String>();
			ArrayList<String> emptyArray = new ArrayList<String>();
			searchedNames.add("project1");
			searchedNames.add("project2");
			searchedNames.add("project3");
			
			project.createProject("project1");
			project.createProject("project2");
			project.createProject("project3");
			
			assertEquals("Failed to search existing projects", searchedNames, project.searchProjects("project"));
			assertEquals("Successfully searched non existing project", emptyArray, project.searchProjects("lala"));
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testProgressBar() throws AssertionError{
		try {
			
			project.createProject(PROJECT_NAME_PROJECT);
			project.addProjectEvent(event1, PROJECT_NAME_PROJECT);
			project.addProjectEvent(event2, PROJECT_NAME_PROJECT);
			project.addProjectEvent(event3, PROJECT_NAME_PROJECT);
			
			event1.setDone(true);
			
			FileHandler fHandler = new FileHandler();
			fHandler.saveNewEventHandler(event1);
			
			assertEquals("Failed to calculate percentage", 33.33, project.progressBar(PROJECT_NAME_PROJECT), 0.01);
			assertEquals("Successfully calculated percentage of a non-existent project", -1, project.progressBar(NON_EXISTENT_PROJECT), 0.01);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}		
	
	@Test
	public void testAddEditDeleteViewProgress() throws AssertionError{
		try {
			project.createProject(PROJECT_NAME_PROJECT);
			project.addProjectEvent(event1, PROJECT_NAME_PROJECT);
			project.addProjectEvent(event2, PROJECT_NAME_PROJECT);
			project.addProjectEvent(event3, PROJECT_NAME_PROJECT);
			
			// sorted event 3,2,1
			
			assertTrue("Failed to add progress message", project.addProgressMessage(0, PROJECT_NAME_PROJECT, OLD_PROGRESS_MESSAGE));
			assertFalse("Successfully added progress message to non-existent project", project.addProgressMessage(0, NON_EXISTENT_PROJECT, "progress message here"));
			
			assertTrue("Failed to edit progress message", project.editProgressMessage(0, NEW_PROGRESS_MESSAGE, PROJECT_NAME_PROJECT));
			assertFalse("Successfully edited progress message in non-existent project", project.editProgressMessage(0, NEW_PROGRESS_MESSAGE, NON_EXISTENT_PROJECT));
	
			assertEquals("Failed to view progress message by index", NEW_PROGRESS_MESSAGE, project.viewEventProgressTimeline(0).get(0).getAdditionalInfo());
			assertEquals("Failed to view progress message by name", NEW_PROGRESS_MESSAGE, project.viewEventProgressTimeline(PROJECT_NAME_PROJECT).get(0).getAdditionalInfo());
			assertNull("Successfully viewed progress message in nonexistent project by index", project.viewEventProgressTimeline(2));
			assertNull("Successfully viewed progress message in nonexistent project by name", project.viewEventProgressTimeline(NON_EXISTENT_PROJECT));
			
			assertTrue("Failed to delete progress message", project.deleteProgressMessage(0, PROJECT_NAME_PROJECT));
			assertFalse("Successfully deleted progress message in non-existent project", project.deleteProgressMessage(0, NON_EXISTENT_PROJECT));
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testSearchItem() throws AssertionError{
		try {
			project.createProject(PROJECT_NAME_PROJECT);
			project.addProjectEvent(event1, PROJECT_NAME_PROJECT);
			project.addProjectEvent(event2, PROJECT_NAME_PROJECT);
			
			//tolowercase
			assertEquals("Failed to search item", "project", project.searchItem(event1));
			assertNull("Successfully searched non exiting item", project.searchItem(event3));
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}		
}
```
###### ./src/test/project/TestProjectHandler.java
``` java
package test.project;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import object.Event;
import object.Item;
import project.ProjectHandler;
import project.Projects;
import storage.FileHandler;

public class TestProjectHandler {

	private static final String PROJECT_NAME_PROJECT = "Project";
	private static final String PROJECT_HELLOALL = "helloAll";
	private static final String MESSAGE_TEAR_DOWN = "Test Files used in ProjectHandler Testing Cleared";
	private static final String MESSAGE_SET_UP = "Files Cleared for ProjectHandler Class Testing";
	protected static FileHandler clear;
	private ProjectHandler pH;
	private Projects project;
	
	// Make sure dates are in DD MMM YYY format 
	private Event event1;
	private Event event2;
	private Event event3;
	
	@Before
	public void setUpBeforeTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_SET_UP);
		
		Item.setCounter(0);
	    event1 = new Event("EventName1", "25 Oct 2015", "26 Oct 2015", "10:00", "21:00", "");
	    event2 = new Event("EventName2", "21 Oct 2015", "31 Oct 2015", "19:00", "23:00", "");
	    event3 = new Event("EventName3", "21 Oct 2015", "30 Oct 2015", "17:00", "02:00", "");
	    pH = new ProjectHandler();
	    project = new Projects();
	    
	    clear.saveNewEventHandler(event1);
	    clear.saveNewEventHandler(event2);
	    clear.saveNewEventHandler(event3);
	}
	
	@After
	public void tearDownAfterTesting() throws Exception {
		clear = new FileHandler();
		clear.clearAll();
		System.out.println(MESSAGE_TEAR_DOWN);
	}
	
	@Test
	public void testAddViewEditDeleteProjectHandlerTimeline() throws AssertionError {
		try {
			
			project.createProject(PROJECT_HELLOALL);
			
			//Add
			assertTrue("Failed to add event to projecthandler by name", pH.addProjectEvent(event1, PROJECT_HELLOALL));
			
			//View
			Integer[] intArray = new Integer[]{0}; 
			assertArrayEquals("Failed to view projecthandler timeline by name", intArray, pH.viewProjectTimeline(PROJECT_HELLOALL).toArray());
			
			Event[] eventArray = new Event[]{event1}; 
			assertArrayEquals("Failed to view projecthandler event timeline by name", eventArray, pH.viewProjectTimelineInEvents(PROJECT_HELLOALL).toArray());
			
			//Pass to-be-edited Event to Parser to call editing in Event Class.
			assertEquals("Failed to edit Event projecthandler", event1, pH.editEvent(0, PROJECT_HELLOALL));
			
			//Delete
			assertTrue("Failed to delete Event by event, projectname in project handler", pH.deleteProjectEvent(event1, PROJECT_HELLOALL));
			assertFalse("Successfully deleted non-existent Event by event, projectname in project handler", pH.deleteProjectEvent(event3, PROJECT_HELLOALL));
			
			project.addProjectEvent(event3, PROJECT_HELLOALL);
			assertTrue("Failed to delete Event by eventindex, projectname in project handler", pH.deleteProjectEvent(0, PROJECT_HELLOALL));
			assertFalse("Successfully deleted non-existent Event by eventindex, projectname in project handler", pH.deleteProjectEvent(1, PROJECT_HELLOALL));		
		
			project.createProject("new name");
			assertTrue("Failed to rename project", pH.editProjectName("new name", "helloall"));

		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testProgressMessageAndProgressBar() throws AssertionError {
		try {
			
			project.createProject(PROJECT_NAME_PROJECT);
			
			// Sort method is tested in add. Sort is private.
			pH.addProjectEvent(event1, PROJECT_NAME_PROJECT);
			pH.addProjectEvent(event2, PROJECT_NAME_PROJECT);
			pH.addProjectEvent(event3, PROJECT_NAME_PROJECT);
			
			//Add prog msg
			//Events sorted: event3,2,1
			assertTrue("Failed to add progress message", pH.addProgressMessage(0, "hello", PROJECT_NAME_PROJECT));
			assertFalse("Successfully added progress message in nonexistent event", pH.addProgressMessage(3, "Harro", PROJECT_NAME_PROJECT));
			
			//Edit prog msg
			assertTrue("Failed to edit progress message", pH.editProgressMessage(0, "This is new", PROJECT_NAME_PROJECT));
			assertFalse("Successfully edited progress message in nonexistent event", pH.editProgressMessage(3, "new message", PROJECT_NAME_PROJECT));
			
			//View prog msg
			assertEquals("Failed to view Event progress timeline", "This is new", pH.viewEventProgressTimeline(PROJECT_NAME_PROJECT).get(0).getAdditionalInfo());
			
			//Delete prog msg
			assertTrue("Failed to delete progress message", pH.deleteProgressMessage(0, PROJECT_NAME_PROJECT));
			assertFalse("Successfully deleted progress message in nonexistent event", pH.deleteProgressMessage(3,PROJECT_NAME_PROJECT));
			assertFalse("Successfully deleted progress message in event that has no message", pH.deleteProgressMessage(0, PROJECT_NAME_PROJECT));
			
			event1.setDone(true);
			
			FileHandler fHandler = new FileHandler();
			fHandler.saveNewEventHandler(event1);
			
			assertEquals("Failed to calculate percentage in project handler", 33.33, pH.progressBar(PROJECT_NAME_PROJECT), 0.01);
			assertEquals("Successfully calculated percentage of a non-existent project in project handler", 0.0, pH.progressBar("nonexistent"), 0.01);
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
	@Test
	public void testFindItem() throws AssertionError {
		try {
			
			project.createProject(PROJECT_NAME_PROJECT);
			
			pH.addProjectEvent(event1, PROJECT_NAME_PROJECT);
			pH.addProjectEvent(event2, PROJECT_NAME_PROJECT);
			pH.addProjectEvent(event3, PROJECT_NAME_PROJECT);
			
			assertTrue("Failed to search for existing event in project", pH.findItem(0, PROJECT_NAME_PROJECT));
			assertFalse("Successfully search for non-existing event in project", pH.findItem(3, PROJECT_NAME_PROJECT));
			
		} catch (AssertionError AE) {
			System.out.println(AE.getMessage());
			throw AE;
		}
	}
	
}

```
